<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ÊàêÂìÅÂ∫´</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="ui_fx.css" />
  <style>
    .page-wrap{max-width:1365px;margin:0 auto;padding:22px 18px 44px;}
    .statusline{margin:10px 0 12px;opacity:.9}
    .errorbox{margin:10px 0 12px;padding:10px 12px;border-radius:12px;background:rgba(255,0,0,.10);border:1px solid rgba(255,0,0,.25);color:#ffb3b3}

    .tabs{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0 14px}
    .tabbtn{cursor:pointer;user-select:none;padding:10px 14px;border-radius:999px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.12);font-size:13px;opacity:.9}
    .tabbtn.active{background:rgba(255,255,255,.14);opacity:1}

    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(210px,1fr));gap:14px}
    .card{border-radius:18px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.10);overflow:hidden;cursor:pointer;transition:.15s;position:relative}
    .card:hover{background:rgba(255,255,255,.07)}
    .thumb{aspect-ratio:3/4;background:rgba(0,0,0,.15);position:relative}
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .thumb .layer{position:absolute;inset:0}
    .thumb .layer img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block}
    .meta{padding:10px 12px}
    .meta .time{font-size:12px;opacity:.85;margin-bottom:4px}
    .meta .parts{font-size:12px;opacity:.65;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    .meta .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .showBtn{
      cursor:pointer;
      user-select:none;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      font-size:12px;
      opacity:.95;
      white-space:nowrap;
    }
    .showBtn:hover{background:rgba(255,255,255,.12)}
    .showBtn:active{transform:translateY(1px)}

    .showBtn.disabled{
      opacity:.5;
      cursor:not-allowed;
      pointer-events:none;
      background:rgba(255,255,255,.04);
    }


    /* Locked recipe cards */
    .locked .thumb{filter:blur(12px) brightness(.5) saturate(.2) contrast(.75);transform:scale(1.08)}
    /* Locked overlay: keep üîí always on top, never affected by blur/filter */
    .lockmask{
      position:absolute;
      inset:0;
      z-index:999; /* always above any layers */
      background:rgba(0,0,0,.40);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      flex-direction:column;

      /* ensure it never inherits blur/filter/backdrop */
      filter:none !important;
      backdrop-filter:none !important;

      /* prevent any weird stacking interactions */
      isolation:isolate;

      /* allow clicks to fall through if you want the card to handle click */
      pointer-events:none;
    }
    .lockmask .lock{
      font-size:28px;
      line-height:1;
      position:relative;
      z-index:1000;
    }
    .lockmask .txt{font-size:13px;opacity:.95}

    .modal{position:fixed;inset:0;background:rgba(0,0,0,.60);display:none;align-items:center;justify-content:center;padding:18px;z-index:9999}
    .modal.show{display:flex}
    .modalbox{width:min(920px,100%);max-height:92vh;border-radius:18px;background:rgba(20,22,30,.96);border:1px solid rgba(255,255,255,.12);overflow:hidden;display:flex;flex-direction:column}
    .modalhead{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.10)}
    .modalhead .h{font-size:14px;opacity:.9}
    .modalhead .x{cursor:pointer;padding:8px 10px;border-radius:999px;background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.10);font-size:12px}
    .modalbody{padding:14px;overflow:auto;max-height:calc(92vh - 54px)}
    .bigwrap{width:100%;aspect-ratio:1365/2048;background:rgba(0,0,0,.20);border-radius:14px;overflow:hidden;position:relative}
    .bigwrap .layer{position:absolute;inset:0}
    .bigwrap .layer img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block}
    .bigwrap img.single{width:100%;height:auto;display:block}
    .footnote{margin-top:10px;font-size:12px;opacity:.75}
    .empty{opacity:.75;padding:14px 0}
  
    :root{
      --ui-main-bg: url('/ui/bg/main_bg.webp');
      --ui-noise: url('/ui/bg/noise.png');
      --ui-vignette: url('/ui/bg/vignette.png');
      --ui-vignette-bg: url('/ui/bg/vignette_bg.webp');
      --ui-particles: url('/ui/effect/particles.webp');
      --ui-panel: url('/ui/frame/panel.webp');
      --ui-card-frame: url('/ui/frame/card_frame.webp');
      --ui-topbar: url('/ui/frame/top_bar.webp');

      --ui-btn-primary: url('/ui/button/btn_primary.webp');
      --ui-btn-primary-hover: url('/ui/button/btn_primary_hover.webp');
      --ui-btn-primary-pressed: url('/ui/button/btn_primary_pressed.webp');
      --ui-btn-gold: url('/ui/button/btn_gold.webp');
      --ui-btn-gem: url('/ui/button/btn_gem.webp');

      --ui-glow-ssr: url('/ui/glow/glow_ssr.webp');
      --ui-glow-ur: url('/ui/glow/glow_ur.webp');
      --ui-starburst: url('/ui/effect/starburst.webp');
    }

    body{
      background:
        var(--ui-vignette-bg),
        var(--ui-vignette),
        var(--ui-noise),
        var(--ui-main-bg);

      background-size:
        cover,
        cover,
        300px 300px,
        cover;

      background-position:
        center,
        center,
        center,
        center;

      background-attachment:
        fixed,
        fixed,
        fixed,
        fixed;
    }

    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: var(--ui-particles) center/cover no-repeat;
      opacity:.12;
      mix-blend-mode: screen;
      z-index:0;
    }


    body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: var(--ui-vignette-bg) center/cover no-repeat;
      opacity:.55;
      mix-blend-mode: multiply;
      z-index:0;
    }

    .page-wrap{position:relative; z-index:1;}

        .page-wrap::before{
      content:"";
      position:absolute;
      inset:14px 12px;
      border-radius:22px;
      background: linear-gradient(180deg, rgba(20,24,34,.72), rgba(10,12,18,.55));
      border: 1px solid rgba(255,255,255,.10);
      box-shadow:
        0 18px 50px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.06);
      pointer-events:none;
      z-index:-1;
    }
    .tabbtn, .showBtn{
      border:none;
      background: var(--ui-btn-primary) center/100% 100% no-repeat;
      padding:12px 18px;
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }
    .tabbtn:hover, .showBtn:hover{
      background-image: var(--ui-btn-primary-hover);
    }
    .tabbtn:active, .showBtn:active{
      background-image: var(--ui-btn-primary-pressed);
      transform: translateY(1px);
    }
    .tabbtn.active{
      background-image: var(--ui-btn-gold);
      opacity:1;
    }

    .showBtn.disabled{
      background-image: var(--ui-btn-primary);
      opacity:.55;
      cursor:not-allowed;
      pointer-events:none;
      box-shadow:none;
      filter:saturate(.6);
    }

    .card{
      background: rgba(255,255,255,.04);
      border:none;
      box-shadow: 0 16px 40px rgba(0,0,0,.30);
    }
    .card::before{
      content:"";
      position:absolute;
      inset:0;
      background: var(--ui-card-frame) center/100% 100% no-repeat;
      pointer-events:none;
      z-index:2;
      opacity:.95;
    }
    .thumb{border-radius:18px; overflow:hidden;}
    .meta{position:relative; z-index:3;}
    .thumb{position:relative; z-index:1;}
    .card:hover{
      transform: translateY(-2px);
      filter: drop-shadow(0 0 18px rgba(255,220,120,.12));
    }

    /* Commercial UI polish */
    .tabs{
      margin: 10px 0 16px;
      gap: 12px;
    }

    .statusline{
      font-size: 13px;
      letter-spacing: .4px;
      text-shadow: 0 2px 10px rgba(0,0,0,.45);
    }

    .grid{
      padding-bottom: 10px;
    }

    .card{
      transform: translateY(0);
      will-change: transform, filter, opacity;
    }

    /* Card entrance animation, JS will add .in */
    .card{
      opacity: 0;
      transform: translateY(18px);
    }
    .card.in{
      opacity: 1;
      transform: translateY(0);
      transition: opacity .28s ease, transform .28s ease, filter .15s ease;
    }

    /* Subtle floating for premium feel */
    @media (prefers-reduced-motion: no-preference){
      .card.in{
        animation: floatCard 7s ease-in-out infinite;
      }
    }
    @keyframes floatCard{
      0%{ transform: translateY(0); }
      50%{ transform: translateY(-6px); }
      100%{ transform: translateY(0); }
    }

    /* Hover light sweep */
    .card::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index:3;
      background:
        radial-gradient(circle at 50% 15%,
          rgba(255,255,255,.28),
          rgba(255,255,255,0) 62%);
      opacity:0;
      transition: opacity .22s ease;
    }
    .card:hover::after{
      opacity:.45;
    }

    /* Premium rim glow on hover */
    .card:hover{
      filter: drop-shadow(0 0 22px rgba(255,220,120,.16));
    }

    /* Optional rarity glow hooks if your API provides r.rarity or s.rarity */
    .card.rarity-ssr{
      filter: drop-shadow(0 0 22px rgba(255,150,60,.22));
    }
    .card.rarity-ur{
      filter: drop-shadow(0 0 26px rgba(255,70,70,.26));
    }

    /* Buttons look like real game buttons */
    .tabbtn, .showBtn{
      text-shadow: 0 2px 8px rgba(0,0,0,.65);
      letter-spacing: .8px;
      font-weight: 700;
    }
    .tabbtn.active{
      filter: drop-shadow(0 0 16px rgba(255,210,120,.22));
    }
    .showBtn{
      background-image: var(--ui-btn-gold);
    }
    .showBtn:hover{
      background-image: var(--ui-btn-primary-hover);
    }
    .showBtn:active{
      background-image: var(--ui-btn-primary-pressed);
    }
    .showBtn.disabled{
      background-image: var(--ui-btn-primary);
      filter: saturate(.55) brightness(.9);
    }

    /* Meta readability */
    .meta .time{
      text-shadow: 0 2px 8px rgba(0,0,0,.55);
    }
    .meta .parts{
      opacity: .72;
    }

    /* Modal polish */
    .modalbox{
      box-shadow: 0 24px 80px rgba(0,0,0,.55);
    }


    /* Header strip and controls */
    .headerStrip{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:16px;
      padding:14px 14px 12px;
      margin: 2px 0 14px;
      border-radius:22px;
      background: linear-gradient(180deg, rgba(12,14,20,.62), rgba(10,12,18,.42));
      border: 1px solid rgba(255,255,255,.10);
      box-shadow:
        0 18px 50px rgba(0,0,0,.45),
        inset 0 1px 0 rgba(255,255,255,.06);
      backdrop-filter: blur(8px);
    }
    .headerLeft{display:flex;flex-direction:column;gap:8px;min-width:260px}
    .headerRight{flex:1;display:flex;justify-content:flex-end}
    .ctrlRow{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;justify-content:flex-end}
    .ctrlGroup{display:flex;flex-direction:column;gap:6px}
    .ctrlLabel{font-size:12px;opacity:.85;letter-spacing:.6px;text-shadow:0 2px 10px rgba(0,0,0,.45)}
    .ctrlSelect,.ctrlInput{
      height:40px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(8,10,14,.45);
      color: rgba(255,255,255,.92);
      padding: 0 12px;
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .ctrlSelect:focus,.ctrlInput:focus{
      border-color: rgba(160,210,255,.28);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.06),
        0 0 0 3px rgba(80,140,255,.10);
    }
    .searchGroup{min-width:260px}
    .ctrlInput{width:100%}

    /* Spinner */
    .spinner{
      width:14px;height:14px;border-radius:999px;
      border:2px solid rgba(255,255,255,.25);
      border-top-color: rgba(255,255,255,.75);
      display:inline-block;
      margin-right:8px;
      animation: spin 1s linear infinite;
      vertical-align:-2px;
    }
    @keyframes spin{to{transform:rotate(360deg);}}

    /* Cleaner meta */
    .meta{padding:12px 12px 12px}
    .meta .parts{display:none}
    .meta .sub{
      margin-top:6px;
      font-size:12px;
      opacity:.75;
      text-shadow: 0 2px 8px rgba(0,0,0,.55);
    }

    /* Better locked */
    .locked .thumb{filter:blur(14px) brightness(.45) saturate(.15) contrast(.8);transform:scale(1.10)}
    .lockmask{background: radial-gradient(circle at 50% 30%, rgba(0,0,0,.25), rgba(0,0,0,.55));}
    .lockmask .lock{
      font-size:30px;
      filter: drop-shadow(0 0 16px rgba(140,200,255,.18));
      animation: lockPulse 2.4s ease-in-out infinite;
    }
    @keyframes lockPulse{
      0%{transform:translateY(0);opacity:.85}
      50%{transform:translateY(-2px);opacity:1}
      100%{transform:translateY(0);opacity:.85}
    }
    .lockmask::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(circle at 20% 15%, rgba(255,255,255,.10), rgba(255,255,255,0) 55%),
        radial-gradient(circle at 80% 35%, rgba(120,180,255,.10), rgba(120,180,255,0) 60%);
      opacity:.55;
      mix-blend-mode: screen;
      animation: shimmer 4.6s ease-in-out infinite;
    }
    @keyframes shimmer{
      0%{transform:translateX(-2%);opacity:.35}
      50%{transform:translateX(2%);opacity:.65}
      100%{transform:translateX(-2%);opacity:.35}
    }

    /* Ripple */
    .card:active{transform: translateY(-1px) scale(.99);}
    .ripple{
      position:absolute;
      border-radius:999px;
      transform: scale(0);
      animation: ripple .55s ease-out;
      background: rgba(255,255,255,.22);
      pointer-events:none;
      z-index:4;
    }
    @keyframes ripple{to{ transform: scale(3.2); opacity:0; }}

    /* Modal actions */
    .modalActions{display:flex;gap:10px;align-items:center;}
    .miniBtn{
      cursor:pointer;
      user-select:none;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size:12px;
      opacity:.95;
      white-space:nowrap;
      text-shadow: 0 2px 8px rgba(0,0,0,.55);
    }
    .miniBtn:hover{background: rgba(255,255,255,.10);}
    .miniBtn:active{transform: translateY(1px);}
    .miniBtn.disabled{opacity:.45;cursor:not-allowed;pointer-events:none;}

    @media (min-width: 1400px){
      .grid{grid-template-columns:repeat(auto-fill,minmax(240px,1fr));}
    }

</style>
</head>
<body>
  <div class="acf-page ui-panel"><div id="acfMasterMount"></div>
  <div class="page-wrap">

    <div class="headerStrip">
      <div class="headerLeft">
        <div class="tabs">
          <div class="tabbtn active" id="tabSaves">ÊàëÁöÑÊàêÂìÅ</div>
          <div class="tabbtn" id="tabRecipes">Recipes</div>
        </div>
        <div class="statusline" id="statusLine"><span class="spinner" id="spin" style="display:none;"></span><span id="statusText">ËÆÄÂèñ‰∏≠</span></div>
      </div>

      <div class="headerRight">
        <div class="ctrlRow">
          <div class="ctrlGroup">
            <label class="ctrlLabel" for="sortSel">ÊéíÂ∫è</label>
            <select id="sortSel" class="ctrlSelect">
              <option value="new">ÊúÄÊñ∞</option>
              <option value="old">ÊúÄËàä</option>
              <option value="rarity">Á®ÄÊúâÂ∫¶</option>
            </select>
          </div>

          <div class="ctrlGroup">
            <label class="ctrlLabel" for="filterSel">ÁØ©ÈÅ∏</label>
            <select id="filterSel" class="ctrlSelect">
              <option value="all">ÂÖ®ÈÉ®</option>
              <option value="unlocked">Â∑≤Ëß£Èéñ</option>
              <option value="locked">Êú™Ëß£Èéñ</option>
              <option value="showing">Â±ïÁ§∫‰∏≠</option>
            </select>
          </div>

          <div class="ctrlGroup searchGroup">
            <label class="ctrlLabel" for="searchInp">ÊêúÂ∞ã</label>
            <input id="searchInp" class="ctrlInput" placeholder="Ëº∏ÂÖ• Recipe ID ÊàñÈóúÈçµÂ≠ó" />
          </div>
        </div>
      </div>
    </div>

<div id="errorBox" class="errorbox" style="display:none;"></div>

    <div class="grid" id="gridSaves"></div>
    <div class="grid" id="gridRecipes" style="display:none;"></div>
  </div>

  <div class="modal" id="modal">
    <div class="modalbox">
      <div class="modalhead">
        <div class="h" id="modalTitle">È†êË¶Ω</div>
        <div class="modalActions">
          <div class="miniBtn disabled" id="btnDownload">‰∏ãËºâÂéüÂúñ</div>
          <div class="miniBtn disabled" id="btnSetAvatar">Ë®≠ÁÇ∫È†≠ÂÉè</div>
          <div class="x" id="modalClose">ÈóúÈñâ</div>
        </div>
      </div>
      <div class="modalbody">
        <div class="bigwrap" id="bigwrap"></div>
        <div class="footnote" id="modalMeta"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const DEFAULT_WORKER = "https://acf-api.dream-league-baseball.workers.dev";
  const WORKER_BASE = window.WORKER_BASE || localStorage.getItem("acf_worker_base") || DEFAULT_WORKER;

  const uid = localStorage.getItem("acf_uid") || "";
  const statusLine = document.getElementById("statusLine");
  const statusText = document.getElementById("statusText");
  const spin = document.getElementById("spin");
  const errorBox = document.getElementById("errorBox");

  const gridSaves = document.getElementById("gridSaves");
  const gridRecipes = document.getElementById("gridRecipes");

  const tabSaves = document.getElementById("tabSaves");
  const tabRecipes = document.getElementById("tabRecipes");

  const modal = document.getElementById("modal");
  const modalClose = document.getElementById("modalClose");
  const modalTitle = document.getElementById("modalTitle");
  const modalMeta = document.getElementById("modalMeta");
  const bigwrap = document.getElementById("bigwrap");

  const sortSel = document.getElementById("sortSel");
  const filterSel = document.getElementById("filterSel");
  const searchInp = document.getElementById("searchInp");

  const btnDownload = document.getElementById("btnDownload");
  const btnSetAvatar = document.getElementById("btnSetAvatar");

  let _activeTab = "saves";
  let _lastSaves = [];
  let _lastRecipes = [];
  let _unlockSet = new Set();
  let _showcaseComboSet = new Set();
  let _modalContext = null;

  function setLoading(on){
    if (spin) spin.style.display = on ? "inline-block" : "none";
  }
  function norm(s){ return String(s || "").toLowerCase().trim(); }
  function rarityRank(r){
    const x = norm(r);
    if (x === "ur") return 5;
    if (x === "ssr") return 4;
    if (x === "sr") return 3;
    if (x === "r") return 2;
    if (x === "c") return 1;
    return 0;
  }
  function applySort(list, timeFn, rarityFn){
    const mode = (sortSel && sortSel.value) ? sortSel.value : "new";
    const arr = list.slice();
    if (mode === "old") arr.sort((a,b) => (timeFn(a)||0) - (timeFn(b)||0));
    else if (mode === "rarity") arr.sort((a,b) => (rarityFn(b)||0) - (rarityFn(a)||0));
    else arr.sort((a,b) => (timeFn(b)||0) - (timeFn(a)||0));
    return arr;
  }
  function applySearch(list, text, keyFn){
    const q = norm(text);
    if (!q) return list;
    return list.filter((x) => norm(keyFn(x)).includes(q));
  }
  function applyFilterSaves(list){
    const f = (filterSel && filterSel.value) ? filterSel.value : "all";
    if (f === "showing"){
      return list.filter((s) => _showcaseComboSet.has(comboKey(s.headId, s.bodyId, s.bgId, s.addon1Id, s.addon2Id)));
    }
    return list;
  }
  function applyFilterRecipes(list){
    const f = (filterSel && filterSel.value) ? filterSel.value : "all";
    if (f === "unlocked") return list.filter((r) => _unlockSet.has(String(r.recipeId)));
    if (f === "locked") return list.filter((r) => !_unlockSet.has(String(r.recipeId)));
    return list;
  }
  function refreshView(){
    if (_activeTab === "recipes") renderRecipes(_lastRecipes, _unlockSet, true);
    else renderSaves(_lastSaves, true);
  }
  if (sortSel) sortSel.onchange = refreshView;
  if (filterSel) filterSel.onchange = refreshView;
  if (searchInp){
    searchInp.addEventListener("keydown", (e) => { if (e.key === "Enter") refreshView(); });
    searchInp.addEventListener("input", () => { if (searchInp.value.length === 0) refreshView(); });
  }


  function setNet(ok){ /* no header badge on this page */ }
  function showError(msg){
    errorBox.style.display = "block";
    errorBox.textContent = msg;
  }
  function clearError(){
    errorBox.style.display = "none";
    errorBox.textContent = "";
  }

  

  if (btnDownload){
    btnDownload.onclick = () => {
      if (btnDownload.classList.contains("disabled")) return;
      if (!_modalContext) return;
      const url = _modalContext.imageUrl || "";
      if (!url){
        showError("Ê≠§È†êË¶ΩÊ≤íÊúâÂèØ‰∏ãËºâÁöÑÂéüÂúñ");
        return;
      }
      try{
        const a = document.createElement("a");
        a.href = url;
        a.download = "image.webp";
        document.body.appendChild(a);
        a.click();
        a.remove();
      }catch(e){
        showError("‰∏ãËºâÂ§±ÊïóÔºö" + (e && e.message ? e.message : String(e)));
      }
    };
  }

  if (btnSetAvatar){
    btnSetAvatar.onclick = async () => {
      if (btnSetAvatar.classList.contains("disabled")) return;
      if (!_modalContext) return;
      if (!uid){
        showError("Ë´ãÂÖàÁôªÂÖ•ÂæåÂÜçË®≠ÁÇ∫È†≠ÂÉè");
        return;
      }
      const url = _modalContext.imageUrl || "";
      if (!url){
        showError("Ê≠§È†êË¶ΩÊ≤íÊúâÂèØÁî®ÁöÑÈ†≠ÂÉèÂúñÁâá");
        return;
      }
      try{
        clearError();
        await apiReq("POST", "/api/me/avatar", { imageUrl: url });
        showError("Â∑≤Ë®≠ÁÇ∫È†≠ÂÉè");
      }catch(e){
        showError("Ë®≠ÁÇ∫È†≠ÂÉèÂ§±ÊïóÔºö" + (e && e.message ? e.message : String(e)));
      }
    };
  }

function api(path){
    return fetch(WORKER_BASE + path, {
      method: "GET",
      headers: {
        "content-type": "application/json",
        "x-user-id": uid || ""
      }
    }).then(async (r) => {
      const t = await r.text();
      let j = {};
      try { j = t ? JSON.parse(t) : {}; } catch { j = { ok:false, error:"bad_json", raw:t }; }
      if (!r.ok || j.ok === false) {
        const e = (j && (j.error || j.message)) ? (j.error || j.message) : ("HTTP " + r.status);
        throw new Error(e + (j && j.detail ? (" - " + j.detail) : ""));
      }
      return j;
    });
  }

  function apiReq(method, path, body){
    return fetch(WORKER_BASE + path, {
      method: method,
      headers: {
        "content-type": "application/json",
        "x-user-id": uid || ""
      },
      body: body ? JSON.stringify(body) : undefined
    }).then(async (r) => {
      const t = await r.text();
      let j = {};
      try { j = t ? JSON.parse(t) : {}; } catch { j = { ok:false, error:"bad_json", raw:t }; }
      if (!r.ok || j.ok === false) {
        const e = (j && (j.error || j.message)) ? (j.error || j.message) : ("HTTP " + r.status);
        throw new Error(e + (j && j.detail ? (" - " + j.detail) : ""));
      }
      return j;
    });
  }


  function fmtTime(ts){
    if (!ts) return "";
    try{
      const d = new Date(ts);
      if (!isFinite(d.getTime())) return String(ts);
      return d.toLocaleString();
    } catch { return String(ts); }
  }

  function openModalLayers(title, metaText, layers){
    _modalContext = { type:"layers", imageUrl:"", layers: layers || [], meta: metaText || "" };
    modalTitle.textContent = title || "È†êË¶Ω";
    modalMeta.textContent = metaText || "";
    bigwrap.innerHTML = "";

    // layers: [{url, z}]
    layers.forEach((l) => {
      if (!l.url) return;
      const div = document.createElement("div");
      div.className = "layer";
      div.style.zIndex = String(l.z || 0);
      const img = document.createElement("img");
      img.loading = "lazy";
      img.src = l.url;
      div.appendChild(img);
      bigwrap.appendChild(div);
    });

    modal.classList.add("show");
    if (btnDownload) btnDownload.classList.remove("disabled");
    if (btnSetAvatar) btnSetAvatar.classList.remove("disabled");

  }

  function openModalSingle(title, metaText, imageUrl){
    _modalContext = { type:"single", imageUrl: imageUrl || "", layers: [], meta: metaText || "" };
    modalTitle.textContent = title || "È†êË¶Ω";
    modalMeta.textContent = metaText || "";
    bigwrap.innerHTML = "";
    // For single image, keep aspect-ratio container but allow scroll in modalbody to see full if needed
    const img = document.createElement("img");
    img.className = "single";
    img.loading = "lazy";
    img.src = imageUrl;
    bigwrap.appendChild(img);
    modal.classList.add("show");
    if (btnDownload) btnDownload.classList.remove("disabled");
    if (btnSetAvatar) btnSetAvatar.classList.remove("disabled");

  }

  modalClose.onclick = () => { modal.classList.remove("show"); if (btnDownload) btnDownload.classList.add("disabled"); if (btnSetAvatar) btnSetAvatar.classList.add("disabled"); };
  modal.onclick = (e) => { if (e.target === modal){ modal.classList.remove("show"); if (btnDownload) btnDownload.classList.add("disabled"); if (btnSetAvatar) btnSetAvatar.classList.add("disabled"); } };
  window.addEventListener("keydown", (e) => { if (e.key === "Escape"){ modal.classList.remove("show"); if (btnDownload) btnDownload.classList.add("disabled"); if (btnSetAvatar) btnSetAvatar.classList.add("disabled"); } });

  function thumbUrl(assetUrl){
    // thumbs disabled: always use original
    return assetUrl || "";
  }


  function addRipple(ev, host){
    try{
      const r = document.createElement("span");
      r.className = "ripple";
      const rect = host.getBoundingClientRect();
      const size = Math.max(rect.width, rect.height) * 0.42;
      r.style.width = r.style.height = size + "px";
      const x = (ev.clientX - rect.left) - size/2;
      const y = (ev.clientY - rect.top) - size/2;
      r.style.left = x + "px";
      r.style.top = y + "px";
      host.appendChild(r);
      setTimeout(() => r.remove(), 650);
    }catch{}
  }

  function markCardIn(card){
    const delay = Math.min(240, (markCardIn._i = (markCardIn._i || 0) + 1) * 18);
    card.style.transitionDelay = delay + "ms";
    requestAnimationFrame(() => card.classList.add("in"));
  }

  function makeStackThumb(container, layers){
    // layers: [{url, z, preferThumb}]
    container.innerHTML = "";
    layers.forEach((l) => {
      if (!l.url) return;
      const div = document.createElement("div");
      div.className = "layer";
      div.style.zIndex = String(l.z || 0);
      const img = document.createElement("img");
      img.loading = "lazy";
      img.src = l.url;
      div.appendChild(img);
      container.appendChild(div);
    });
  }

  function setTab(which){
    _activeTab = (which === "recipes") ? "recipes" : "saves";
    if (filterSel){
      const v = filterSel.value || "all";
      Array.from(filterSel.options || []).forEach((o) => {
        if (o.value === "showing") o.disabled = (_activeTab !== "saves");
        if (o.value === "locked" || o.value === "unlocked") o.disabled = (_activeTab !== "recipes");
      });
      if ((_activeTab !== "saves" && v === "showing") || (_activeTab !== "recipes" && (v === "locked" || v === "unlocked"))){
        filterSel.value = "all";
      }
    }

    if (which === "recipes"){
      tabRecipes.classList.add("active");
      tabSaves.classList.remove("active");
      gridRecipes.style.display = "grid";
      gridSaves.style.display = "none";
      statusText.textContent = "ËÆÄÂèñ‰∏≠";
      clearError();
      loadRecipes();
    } else {
      tabSaves.classList.add("active");
      tabRecipes.classList.remove("active");
      gridSaves.style.display = "grid";
      gridRecipes.style.display = "none";
      statusText.textContent = "ËÆÄÂèñ‰∏≠";
      clearError();
      loadSaves();
    }
  }

  tabSaves.onclick = () => setTab("saves");
  tabRecipes.onclick = () => setTab("recipes");

  async function loadSaves(){
    setLoading(true);
    gridSaves.innerHTML = "";
    try{
      const res = await api("/api/me/saves");
      setNet(true);

    const comboKey = (headId, bodyId, bgId, addon1Id, addon2Id) => {
      const a = [String(addon1Id || ""), String(addon2Id || "")].sort();
      return [String(headId || ""), String(bodyId || ""), String(bgId || ""), a[0], a[1]].join("|");
    };

    _showcaseComboSet = new Set();
    try{
      const all = await api("/api/me/showcases?seasonId=S1");
      const list = all.showcases || [];
      list.forEach((x) => {
        _showcaseComboSet.add(comboKey(x.headId, x.bodyId, x.bgId, x.addon1Id, x.addon2Id));
      });
    }catch(e){
      // If this fails, we should NOT silently ignore it, otherwise users can't tell why "Â±ïÁ§∫‰∏≠" never appears.
      console.warn("load showcases failed", e);
      showError("ËÆÄÂèñÂ±ïÁ§∫Ë≥áÊñôÂ§±ÊïóÔºåË´ãÁ¢∫Ë™çÂ∑≤Êõ¥Êñ∞ Worker ‰∏¶‰∏î WORKER_BASE ÊåáÂêëÂêå‰∏ÄÂÄãË≥áÊñôÂ∫´");
    }

      const saves = res.saves || [];
      statusText.textContent = "ÂÖ± " + saves.length + " ÂÄãÊàêÂìÅ";

      saves.forEach((s) => {
        const card = document.createElement("div");
        card.className = "card";

        if (s && s.rarity){
          const rr = String(s.rarity).toLowerCase();
          if (rr === "ssr") card.classList.add("rarity-ssr");
          if (rr === "ur") card.classList.add("rarity-ur");
        }

        const th = document.createElement("div");
        th.className = "thumb";

        // Layer order (top->bottom):
        // addon1 top, body 2, head 3, addon2 4, bg bottom
        const layersThumb = [
          { url: s.bgUrl, z: 10, preferThumb:false },
          { url: s.addon2Url, z: 20, preferThumb:false },
          { url: s.headUrl, z: 30, preferThumb:false },
          { url: s.bodyUrl, z: 40, preferThumb:false },
          { url: s.addon1Url, z: 50, preferThumb:false },
        ];
        makeStackThumb(th, layersThumb);

        const meta = document.createElement("div");
        meta.className = "meta";

        const row = document.createElement("div");
        row.className = "row";

        const time = document.createElement("div");
        time.className = "time";
        time.textContent = fmtTime(s.savedOn);

        const btnShow = document.createElement("div");
        btnShow.className = "showBtn";
        
        let isShowing = showcaseComboSet.has(comboKey(s.headId, s.bodyId, s.bgId, s.addon1Id, s.addon2Id));
        btnShow.textContent = isShowing ? "Â±ïÁ§∫‰∏≠" : "Â±ïÁ§∫";
        if (isShowing){
          btnShow.classList.add("disabled");
        }


        btnShow.onclick = async (ev) => {
          if (btnShow.classList.contains("disabled")) return;
          ev.stopPropagation();
          clearError();

          if (!uid){
            showError("Ë´ãÂÖàÁôªÂÖ•ÂæåÂÜç‰ΩøÁî®Â±ïÁ§∫ÂäüËÉΩ");
            return;
          }

          const payload = {
            saveId: s.saveId || s.id || null,
            headId: s.headId || null,
            bodyId: s.bodyId || null,
            bgId: s.bgId || null,
            addon1Id: s.addon1Id || null,
            addon2Id: s.addon2Id || null,
            headUrl: s.headUrl || null,
            bodyUrl: s.bodyUrl || null,
            bgUrl: s.bgUrl || null,
            addon1Url: s.addon1Url || null,
            addon2Url: s.addon2Url || null,
            savedOn: s.savedOn || null
          };

          try{
            const cur = await api("/api/me/showcase?seasonId=S1");
            const curItem = cur.showcase || cur.item || cur.current || null;
if (curItem){
              const ok = window.confirm("Êú¨ÊúüÂ∑≤Á∂ìÊúâ‰ΩúÂìÅÊ≠£Âú®Â±ïÁ§∫‰∏≠„ÄÇ‰∏äÂÇ≥Êñ∞‰ΩúÂìÅÂæåÔºåÂéüÊúâÁöÑÁ•®Êï∏Â∞áÊ≠∏Èõ∂‰∏¶ÈáçÊñ∞Ë®àÁ•®„ÄÇÊòØÂê¶Á¢∫Ë™çÔºü");
              if (!ok) return;
            }

            await apiReq("POST", "/api/me/showcase", { ...payload, seasonId:"S1", overwrite: !!curItem });

            // Immediately reflect UI state
            _showcaseComboSet.add(comboKey(payload.headId, payload.bodyId, payload.bgId, payload.addon1Id, payload.addon2Id));
            btnShow.textContent = "Â±ïÁ§∫‰∏≠";
            btnShow.classList.add("disabled");
            showError("Â∑≤Êèê‰∫§Â±ïÁ§∫");
            setLoading(false);
      setLoading(false);
    } catch(e){
            showError("Â±ïÁ§∫Â§±ÊïóÔºö" + (e && e.message ? e.message : String(e)));
            console.error(e);
          }
        };

        row.appendChild(time);
        row.appendChild(btnShow);

        const parts = document.createElement("div");
        parts.className = "parts";
        parts.textContent = [s.headId, s.bodyId, s.bgId].filter(Boolean).join(" / ");

        meta.appendChild(row);
        meta.appendChild(parts);

        card.appendChild(th);
        card.appendChild(meta);

        card.onclick = (ev) => {
        addRipple(ev, card);
          const layersBig = [
            { url: s.bgUrl, z: 10 },
            { url: s.addon2Url, z: 20 },
            { url: s.headUrl, z: 30 },
            { url: s.bodyUrl, z: 40 },
            { url: s.addon1Url, z: 50 },
          ];
          openModalLayers("ÊàëÁöÑÊàêÂìÅ", fmtTime(s.savedOn), layersBig);
        };

        gridSaves.appendChild(card);
        markCardIn(card);
      });

    } catch(e){
      setLoading(false);
      setNet(false);
      statusText.textContent = "ËÆÄÂèñÂ§±Êïó";
      showError("ËÆÄÂèñÂ§±ÊïóÔºåË´ãÁ¢∫Ë™çÂæåÁ´ØÂ∑≤Êõ¥Êñ∞Ôºå‰∏¶‰∏îÊúâË≥áÊñôÂ∫´Ë°® user_saves");
      console.error(e);
    }
  }


  function renderSaves(saves, fromControls){
    _lastSaves = saves || [];
    gridSaves.innerHTML = "";

    const text = (searchInp && searchInp.value) ? searchInp.value : "";
    let list = applySort(_lastSaves, (s) => (s && s.savedOn ? new Date(s.savedOn).getTime() : 0), (s) => rarityRank(s && s.rarity));
    list = applyFilterSaves(list);
    list = applySearch(list, text, (s) => [s.saveId, s.id, s.headId, s.bodyId, s.bgId, s.rarity].filter(Boolean).join(" "));

    statusText.textContent = "ÂÖ± " + list.length + " ÂÄãÊàêÂìÅ";

    if (list.length == 0){
      gridSaves.innerHTML = '<div class="empty">Ê≤íÊúâÁ¨¶ÂêàÊ¢ù‰ª∂ÁöÑÊàêÂìÅ</div>';
      return;
    }

    list.forEach((s) => {
      const card = document.createElement("div");
      card.className = "card";

      if (s && s.rarity){
        const rr = String(s.rarity).toLowerCase();
        if (rr === "ssr") card.classList.add("rarity-ssr");
        if (rr === "ur") card.classList.add("rarity-ur");
      }

      const th = document.createElement("div");
      th.className = "thumb";

      const layersThumb = [
        { url: s.bgUrl, z: 10, preferThumb:false },
        { url: s.addon2Url, z: 20, preferThumb:false },
        { url: s.headUrl, z: 30, preferThumb:false },
        { url: s.bodyUrl, z: 40, preferThumb:false },
        { url: s.addon1Url, z: 50, preferThumb:false },
      ];
      makeStackThumb(th, layersThumb);

      const meta = document.createElement("div");
      meta.className = "meta";

      const row = document.createElement("div");
      row.className = "row";

      const time = document.createElement("div");
      time.className = "time";
      time.textContent = fmtTime(s.savedOn);

      const btnShow = document.createElement("div");
      btnShow.className = "showBtn";

      let isShowing = _showcaseComboSet.has(comboKey(s.headId, s.bodyId, s.bgId, s.addon1Id, s.addon2Id));
      btnShow.textContent = isShowing ? "Â±ïÁ§∫‰∏≠" : "Â±ïÁ§∫";
      if (isShowing) btnShow.classList.add("disabled");

      btnShow.onclick = async (ev) => {
        if (btnShow.classList.contains("disabled")) return;
        ev.stopPropagation();
        clearError();

        if (!uid){
          showError("Ë´ãÂÖàÁôªÂÖ•ÂæåÂÜç‰ΩøÁî®Â±ïÁ§∫ÂäüËÉΩ");
          return;
        }

        const payload = {
          saveId: s.saveId || s.id || null,
          headId: s.headId || null,
          bodyId: s.bodyId || null,
          bgId: s.bgId || null,
          addon1Id: s.addon1Id || null,
          addon2Id: s.addon2Id || null,
          headUrl: s.headUrl || null,
          bodyUrl: s.bodyUrl || null,
          bgUrl: s.bgUrl || null,
          addon1Url: s.addon1Url || null,
          addon2Url: s.addon2Url || null,
          savedOn: s.savedOn || null
        };

        try{
          const cur = await api("/api/me/showcase?seasonId=S1");
          const curItem = cur.showcase || cur.item || cur.current || null;
          if (curItem){
            const ok = window.confirm("Êú¨ÊúüÂ∑≤Á∂ìÊúâ‰ΩúÂìÅÊ≠£Âú®Â±ïÁ§∫‰∏≠„ÄÇ‰∏äÂÇ≥Êñ∞‰ΩúÂìÅÂæåÔºåÂéüÊúâÁöÑÁ•®Êï∏Â∞áÊ≠∏Èõ∂‰∏¶ÈáçÊñ∞Ë®àÁ•®„ÄÇÊòØÂê¶Á¢∫Ë™çÔºü");
            if (!ok) return;
          }

          await apiReq("POST", "/api/me/showcase", { ...payload, seasonId:"S1", overwrite: !!curItem });

          _showcaseComboSet.add(comboKey(payload.headId, payload.bodyId, payload.bgId, payload.addon1Id, payload.addon2Id));
          btnShow.textContent = "Â±ïÁ§∫‰∏≠";
          btnShow.classList.add("disabled");
          showError("Â∑≤Êèê‰∫§Â±ïÁ§∫");
        } catch(e){
          showError("Â±ïÁ§∫Â§±ÊïóÔºö" + (e && e.message ? e.message : String(e)));
        }
      };

      row.appendChild(time);
      row.appendChild(btnShow);

      const sub = document.createElement("div");
      sub.className = "sub";
      sub.textContent = s && s.rarity ? ("Á®ÄÊúâÂ∫¶ " + String(s.rarity).toUpperCase()) : "Â∑≤ÂÑ≤Â≠òÊàêÂìÅ";

      meta.appendChild(row);
      meta.appendChild(sub);

      card.appendChild(th);
      card.appendChild(meta);

      card.onclick = (ev) => {
        addRipple(ev, card);

        const layersBig = [
          { url: s.bgUrl, z: 10 },
          { url: s.addon2Url, z: 20 },
          { url: s.headUrl, z: 30 },
          { url: s.bodyUrl, z: 40 },
          { url: s.addon1Url, z: 50 },
        ];

        const metaText = "ÊôÇÈñì " + fmtTime(s.savedOn) + "    head " + (s.headId || "-") + "    body " + (s.bodyId || "-") + "    bg " + (s.bgId || "-");
        _modalContext = { type:"layers", imageUrl: (s.headUrl || s.bodyUrl || s.bgUrl || ""), layers: layersBig, meta: metaText };

        openModalLayers("ÊàëÁöÑÊàêÂìÅ", metaText, layersBig);
      };

      gridSaves.appendChild(card);
      markCardIn(card);
    });
  }

  function renderRecipes(recipes, unlockSet, fromControls){
    _lastRecipes = recipes || [];
    _unlockSet = unlockSet || new Set();
    gridRecipes.innerHTML = "";

    const text = (searchInp && searchInp.value) ? searchInp.value : "";
    let list = applySort(_lastRecipes, (r) => (r && r.recipeId != null ? Number(r.recipeId) : 0), (r) => rarityRank(r && r.rarity));
    list = applyFilterRecipes(list);
    list = applySearch(list, text, (r) => [r.recipeId, r.imageUrl, r.rarity].filter(Boolean).join(" "));

    statusText.textContent = "ÂÖ± " + list.length + " Âºµ Recipes";

    if (list.length === 0){
      gridRecipes.innerHTML = '<div class="empty">Ê≤íÊúâÁ¨¶ÂêàÊ¢ù‰ª∂ÁöÑ Recipes</div>';
      return;
    }

    list.forEach((r) => {
      const unlocked = unlockSet.has(String(r.recipeId));

      const card = document.createElement("div");
      card.className = "card" + (unlocked ? "" : " locked");

      if (r && r.rarity){
        const rr = String(r.rarity).toLowerCase();
        if (rr === "ssr") card.classList.add("rarity-ssr");
        if (rr === "ur") card.classList.add("rarity-ur");
      }

      const th = document.createElement("div");
      th.className = "thumb";
      const img = document.createElement("img");
      img.loading = "lazy";
      img.src = r.imageUrl;
      th.appendChild(img);

      if (!unlocked){
        const mask = document.createElement("div");
        mask.className = "lockmask";
        mask.innerHTML = '<div class="lock">üîí</div><div class="txt">Êú™Ëß£Èéñ</div>';
        card.appendChild(mask);
      }

      const meta = document.createElement("div");
      meta.className = "meta";
      const time = document.createElement("div");
      time.className = "time";
      time.textContent = "Recipe #" + r.recipeId;
      const sub = document.createElement("div");
      sub.className = "sub";
      sub.textContent = unlocked ? "Â∑≤Ëß£Èéñ ÂèØÊü•ÁúãÂéüÂúñ" : "Êú™Ëß£Èéñ";
      meta.appendChild(time);
      meta.appendChild(sub);

      card.appendChild(th);
      card.appendChild(meta);

      card.onclick = (ev) => {
        addRipple(ev, card);
        if (!unlocked){
          showError("Ê≠§ÊàêÂìÅÂ∞öÊú™Ëß£Èéñ");
          return;
        }
        clearError();
_modalContext = { type:"single", imageUrl: r.imageUrl || "", layers: [], meta: "Recipe " + r.recipeId };
        openModalSingle("Recipe #" + r.recipeId, "Â∑≤Ëß£Èéñ", r.imageUrl);
      };

      gridRecipes.appendChild(card);
      markCardIn(card);
    });
  }

  async function loadRecipes(){
    setLoading(true);
    gridRecipes.innerHTML = "";
    try{
      const [r1, r2] = await Promise.all([
        api("/api/recipes"),
        api("/api/me/unlocks"),
      ]);
      setNet(true);

      const recipes = r1.recipes || [];
      const unlocks = r2.unlocks || [];
      const unlockSet = new Set(unlocks.map((x) => String(x)));

      renderRecipes(recipes, unlockSet, false);
      setLoading(false);

    } catch(e){
      setLoading(false);
      setNet(false);
      statusText.textContent = "ËÆÄÂèñÂ§±Êïó";
      showError("ËÆÄÂèñÂ§±ÊïóÔºåË´ãÁ¢∫Ë™çÂæåÁ´ØÂ∑≤Êúâ /api/recipes Ëàá /api/me/unlocksÔºå‰∏¶‰∏îË≥áÊñôÂ∫´Â≠òÂú® recipes / user_unlocks");
      console.error(e);
    }
  }

  // initial
  setTab("saves");
})();
</script>
  <script src="app.js"></script>
  </div>
</body>
</html>
