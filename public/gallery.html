<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>展示牆</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="container">
    <div class="topbar">
      <a class="brand" href="index.html">
        <div class="logo"></div>
        <h1>Anime Character Forge</h1>
      </a>
      <div class="right">
        <div class="badge" id="netBadge">Connecting</div>
        <a class="badge" href="profile.html">My</a>
      </div>
    </div>

    
<div class="card">
  <div class="cardHeader">
    <h2>展示牆</h2>
    <div class="right">
      <a class="badge" href="hub.html">返回</a>
    </div>
  </div>
  <div class="cardBody">
    <div class="grid">
      <div class="col5">
        <div class="notice">
          每個玩家對同一作品只能評分 1 次
          你可以先離線玩 部署後就會變成全站共用排行榜
        </div>
        <div class="hr"></div>
        <button class="btn" id="refreshBtn">刷新</button>
      </div>
      <div class="col7">
        <div class="stage" style="aspect-ratio: 16 / 9;">
          <img class="layer" id="pvBg" alt="bg" />
          <img class="layer" id="pvAddon2" alt="addon2" />
          <img class="layer" id="pvHead" alt="head" />
          <img class="layer" id="pvBody" alt="body" />
          <img class="layer" id="pvAddon1" alt="addon1" />
        </div>
        <div style="height:10px"></div>
        <table class="table" id="buildTable">
          <thead>
            <tr>
              <th>標題</th>
              <th>作者</th>
              <th>分數</th>
              <th>評分</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

  </div>

  <script src="app.js"></script>
  
<script>
(async function(){
  await initSession();
  q("#netBadge").textContent = APP.offline ? "Offline" : "Online";

  const db = offlineDb();
  const cached = getAssetsCached();
  const assetsAll = (cached && cached.length) ? cached : db.assets;
  const byId = new Map(assetsAll.map(a=>[a.assetId,a]));

  function setPreview(item){
    const bg = item.bgUrl || byId.get(item.bgId)?.imageUrl || "";
    const a2 = item.addon2Url || (item.addon2Id ? byId.get(item.addon2Id)?.imageUrl : "") || "";
    const head = item.headUrl || byId.get(item.headId)?.imageUrl || "";
    const body = item.bodyUrl || byId.get(item.bodyId)?.imageUrl || "";
    const a1 = item.addon1Url || (item.addon1Id ? byId.get(item.addon1Id)?.imageUrl : "") || "";

    q("#pvBg").src = bg;
    q("#pvAddon2").src = a2;
    q("#pvHead").src = head;
    q("#pvBody").src = body;
    q("#pvAddon1").src = a1;

    q("#pvAddon2").style.display = a2 ? "block" : "none";
    q("#pvAddon1").style.display = a1 ? "block" : "none";
  }

  async function listOnline(){
    try{
      const data = await api("/api/gallery", { method:"GET" });
      if(!data || !data.ok) return null;
      return data;
    }catch(e){
      return null;
    }
  }

  async function listOffline(){
    // offline builds may not have urls
    return { ok:true, items: (db.builds||[]).slice(0,100).map(b=>({
      showcaseId: b.buildId,
      userId: b.uid,
      title: b.title,
      headId: b.headId,
      bodyId: b.bodyId,
      bgId: b.bgId,
      addon1Id: (b.accessoryIds||[])[0] || "",
      addon2Id: (b.accessoryIds||[])[1] || "",
      avgScore: b.scoreCount ? (b.scoreSum/b.scoreCount) : 0,
      votes: b.scoreCount || 0,
      createdAt: b.createdAt || 0
    })) };
  }

  async function voteOnline(showcaseId, score){
    try{
      return await api("/api/vote", {
        method:"POST",
        body: JSON.stringify({ showcaseId, score })
      });
    }catch(e){
      return null;
    }
  }

  function scoreText(it){
    const avg = Number(it.avgScore || 0);
    const cnt = Number(it.votes || 0);
    return `${avg.toFixed(1)}  ${cnt}`;
  }

  function render(items){
    const tbody = q("#buildTable tbody");
    tbody.innerHTML = "";
    if(!items || items.length === 0){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="4">還沒有作品 先去工作室提交</td>`;
      tbody.appendChild(tr);
      setPreview({ bgId:"", headId:"", bodyId:"" });
      return;
    }

    setPreview(items[0]);

    items.forEach((it, idx)=>{
      const tr = document.createElement("tr");
      const author = (it.userId || "anon").slice(0,6);
      const title = it.title || `作品 ${idx+1}`;
      tr.innerHTML = `
        <td><a href="#" data-id="${it.showcaseId}" class="pick">${title}</a></td>
        <td>${author}</td>
        <td>${scoreText(it)}</td>
        <td>
          <select data-id="${it.showcaseId}" class="input" style="padding:8px;border-radius:12px">
            <option value="">給分</option>
            <option value="5">5</option>
            <option value="4">4</option>
            <option value="3">3</option>
            <option value="2">2</option>
            <option value="1">1</option>
          </select>
        </td>
      `;
      tbody.appendChild(tr);
    });

    qa("a.pick").forEach(a=>{
      a.addEventListener("click", (e)=>{
        e.preventDefault();
        const id = a.getAttribute("data-id");
        const it = items.find(x=>x.showcaseId===id);
        if(it) setPreview(it);
      });
    });

    qa("select[data-id]").forEach(s=>{
      s.addEventListener("change", async ()=>{
        const showcaseId = s.getAttribute("data-id");
        const score = Number(s.value||0);
        if(!score) return;

        toast("送出評分");
        let r = await voteOnline(showcaseId, score);
        if(!r){
          toast("目前離線無法評分");
          s.value = "";
          return;
        }
        if(r.ok){
          toast("已評分");
          await load();
        }else{
          toast("評分失敗");
        }
        s.value = "";
      });
    });
  }

  async function load(){
    let data = await listOnline();
    if(!data) data = await listOffline();
    q("#netBadge").textContent = APP.offline ? "Offline" : "Online";
    const items = (data.items || []).slice();
    // sort top by avgScore then votes
    items.sort((a,b)=>{
      const aa = Number(a.avgScore||0);
      const bb = Number(b.avgScore||0);
      if(bb !== aa) return bb-aa;
      const av = Number(a.votes||0);
      const bv = Number(b.votes||0);
      if(bv !== av) return bv-av;
      return Number(b.createdAt||0) - Number(a.createdAt||0);
    });
    render(items);
  }

  q("#refreshBtn").addEventListener("click", load);

  await load();
})();
</script>

</body>
</html>
