<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>工作室 - 進階版</title>
  <link rel="stylesheet" href="style.css" />
<style id="thumbStyle">
  .picker-section{margin-bottom:14px; display: none;}
  .picker-section.active{display: block;}
  .picker-title{font-size:14px;opacity:.9;margin:10px 0 10px; display: none;}
  
  /* Tabs Styling */
  .tabs-container {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
    overflow-x: auto;
    padding-bottom: 4px;
  }
  .tab-btn {
    padding: 8px 16px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
    white-space: nowrap;
    font-size: 13px;
    transition: all 0.2s;
  }
  .tab-btn.active {
    background: rgba(74,222,128,0.2);
    border-color: rgba(74,222,128,0.5);
    color: #4ade80;
  }

  .asset-grid{
    position: relative;
    height: 400px; /* Increased height for better tab view */
    overflow: auto;
    padding: 10px;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.10);
    background: rgba(0,0,0,0.12);
  }
  .asset-spacer{width:100%; position:relative;}
  .asset-item{
    position:absolute;
    width:64px;
    height:96px;
  }
  .asset-thumb{
    width:64px;
    height:96px;
    border-radius:12px;
    border:2px solid rgba(255,255,255,0.18);
    cursor:pointer;
    object-fit:contain;
    background: rgba(0,0,0,0.20);
    display:block;
  }
  .asset-thumb.active{outline:2px solid rgba(239,68,68,0.95); outline-offset:2px;}

  /* rarity borders */
  .r1 .asset-thumb{border-color: rgba(148,163,184,0.75);}
  .r2 .asset-thumb{border-color: rgba(34,197,94,0.75);}
  .r3 .asset-thumb{border-color: rgba(59,130,246,0.75);}
  .r4 .asset-thumb{border-color: rgba(168,85,247,0.75);}
  .r5 .asset-thumb{border-color: rgba(245,158,11,0.85);}

  /* Count Badge (Top Right) */
  .badge-count {
    position: absolute;
    right: -4px;
    top: -4px;
    background: rgba(0,0,0,0.75);
    color: #fff;
    font-size: 10px;
    padding: 2px 5px;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.2);
    z-index: 2;
    pointer-events: none;
  }

  /* upgrade-ready / not-ready styling for count badge */
  .badge-count.ready{
    background: rgba(250,204,21,0.90);
    color: #111827;
    border-color: rgba(250,204,21,0.95);
    box-shadow: 0 0 0 1px rgba(250,204,21,0.55), 0 10px 20px rgba(0,0,0,0.35);
  }
  .badge-count.notready{
    background: rgba(0,0,0,0.75);
    color: rgba(239,68,68,0.95);
    border-color: rgba(239,68,68,0.45);
  }
  .badge-count.gray{
    background: rgba(0,0,0,0.75);
    color: rgba(148,163,184,0.95);
    border-color: rgba(148,163,184,0.35);
  }

  /* upgrade overlay */
  .upgrade-overlay{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    border-radius:12px;
    background: rgba(0,0,0,0.45);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index: 4;
    cursor: pointer;
  }
  .upgrade-overlay span{
    font-size: 12px;
    font-weight: 800;
    padding: 6px 10px;
    border-radius: 999px;
    background: rgba(250,204,21,0.92);
    color: #111827;
    border: 1px solid rgba(250,204,21,0.95);
    box-shadow: 0 10px 24px rgba(0,0,0,0.45);
  }

  /* upgrade animation */
  .asset-item.upgrading .asset-thumb{
    animation: upgradePulse 650ms ease-in-out 1;
  }
  .asset-item.upgrading{
    filter: drop-shadow(0 0 10px rgba(250,204,21,0.55));
  }
  @keyframes upgradePulse{
    0%{ transform: scale(1); }
    35%{ transform: scale(1.06); }
    70%{ transform: scale(0.99); }
    100%{ transform: scale(1); }
  }

  /* Rarity Badge (Top Left) */
  .badge-rarity{
    position:absolute;
    left:-4px;
    top:-4px;
    background: rgba(0,0,0,0.75);
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.12);
    z-index: 2;
    pointer-events:none;
    font-weight: 700;
    letter-spacing: 0.5px;
  }
  .r1 .badge-rarity{ color: rgba(148,163,184,0.95); border-color: rgba(148,163,184,0.6); }
  .r2 .badge-rarity{ color: rgba(34,197,94,0.95); border-color: rgba(34,197,94,0.6); }
  .r3 .badge-rarity{ color: rgba(59,130,246,0.95); border-color: rgba(59,130,246,0.6); }
  .r4 .badge-rarity{ color: rgba(168,85,247,0.95); border-color: rgba(168,85,247,0.6); }
  .r5 .badge-rarity{ color: rgba(245,158,11,0.98); border-color: rgba(245,158,11,0.7); }

  /* Star Badge (Bottom Right) */
  .badge-stars {
    position: absolute;
    right: 4px;
    bottom: 4px;
    color: #fbbf24;
    font-size: 13px;
    font-weight: 700;
    background: rgba(0,0,0,0.65);
    border: 1px solid rgba(255,255,255,0.18);
    padding: 2px 6px;
    border-radius: 8px;
    text-shadow: 0 0 4px rgba(0,0,0,0.9);
    z-index: 2;
    pointer-events: none;
  }

  /* unlocked tick */
  .badge-unlocked{
    position:absolute;
    right: 20px; /* Shifted to avoid overlap with count */
    top:-6px;
    width:18px;
    height:18px;
    border-radius:999px;
    background: rgba(34,197,94,0.95);
    color:#04130a;
    font-weight:800;
    font-size:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    pointer-events:none;
    z-index: 3;
  }

  /* hover preview */
  #hoverPreview{
    position: fixed;
    z-index: 9999;
    width: 213px;
    height: 320px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(10px);
    display:none;
    overflow:hidden;
    pointer-events:none;
    box-shadow: 0 24px 70px rgba(0,0,0,0.55);
  }
  #hoverPreview img{
    width:100%;
    height:100%;
    object-fit:contain;
  }

  /* Star badge tweak: slightly smaller, shift right/down for 5 stars */
  .badge-stars{
    font-size: 11px;
    padding: 2px 4px;
    right: 2px;
    bottom: 2px;
    letter-spacing: -0.8px;
    transform: translate(2px, 2px);
  }

  /* Body-missing mask to hide parts that should be covered by body */
  .body-missing-mask{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    pointer-events:none;
    display:none;
    z-index: 50;
    border-radius: 18px;
    background: linear-gradient(
      to bottom,
      rgba(0,0,0,0.00) 0%,
      rgba(0,0,0,0.00) 22%,
      rgba(0,0,0,0.45) 28%,
      rgba(0,0,0,0.62) 100%
    );
    backdrop-filter: blur(1px);
  }

  /* Level up FX */
  #levelUpFx{
    position: fixed;
    inset: 0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index: 10000;
    pointer-events:none;
    background: rgba(0,0,0,0.25);
    backdrop-filter: blur(2px);
  }
  #levelUpFx.active{ display:flex; }
  #levelUpFx .levelUpCard{
    padding: 18px 22px;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.22);
    background: rgba(0,0,0,0.65);
    color: #fff;
    font-weight: 900;
    letter-spacing: 1px;
    text-transform: uppercase;
    box-shadow: 0 30px 90px rgba(0,0,0,0.55);
    animation: levelUpPop 1100ms ease-in-out 1;
  }
  #levelUpFx .levelUpSub{
    margin-top: 8px;
    font-size: 12px;
    font-weight: 700;
    opacity: 0.85;
    letter-spacing: 0.3px;
    text-align:center;
  }
  @keyframes levelUpPop{
    0%{ transform: translateY(10px) scale(0.92); opacity: 0; }
    18%{ transform: translateY(0) scale(1.02); opacity: 1; }
    55%{ transform: translateY(0) scale(1); opacity: 1; }
    100%{ transform: translateY(-6px) scale(0.98); opacity: 0; }
  }

  /* Stage preview a bit larger */
  .stage{ overflow: hidden; }
  /* Stage uses original asset dimensions (set via CSS vars from loaded images) */
  .stage{
    width: var(--stageW, 420px);
    height: var(--stageH, 620px);
  }
  .stage .layer{
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  
  /* Disabled / unselectable assets */
  .asset-item.disabled{
    opacity: 0.35;
    filter: grayscale(1);
    pointer-events: auto;
  }
  .asset-item.disabled::after{
    content: "不可選";
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 800;
    letter-spacing: 1px;
    color: #fff;
    background: rgba(0,0,0,0.45);
    border-radius: 14px;
  }


  /* Collection unlock FX */
  #collectionFx{
    position: fixed;
    inset: 0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index: 10001;
    pointer-events:none;
    background: rgba(0,0,0,0.22);
    backdrop-filter: blur(2px);
  }
  #collectionFx.active{ display:flex; }

</style>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <a class="brand" href="index.html">
        <div class="logo"></div>
        <h1>Anime Character Forge</h1>
      </a>
      <div class="right">
        <div class="badge" id="netBadge">Connecting</div>
        <a class="badge" href="profile.html">My</a>
      </div>
    </div>

    <div class="card">
      <div class="cardHeader">
        <h2>工作室</h2>
        <a class="badge" href="hub.html">返回</a>
      </div>
      <div class="cardBody">
        <div class="grid">
          <div class="col7">
            <div class="stage">
<img class="layer" id="bgLayer" alt="background" />
<img class="layer" id="addon2Layer" alt="add on 2" />
<img class="layer" id="headLayer" alt="head" />
<img class="layer" id="bodyLayer" alt="body" />
<img class="layer" id="addon1Layer" alt="add on 1" />


              <div id="bodyMissingMask" class="body-missing-mask"></div>
              <div class="stageOverlay">
                <button class="smallBtn" id="randomBtn">隨機搭配</button>
                <button class="smallBtn" id="submitBtn">保存</button>
              </div>
            </div>
            <div style="height:10px"></div>
            <input class="input" id="titleInput" placeholder="作品標題 例如 Neon Queen" />
            <div style="height:10px"></div>
            <div class="help" id="unlockHint"></div>
          </div>

          <div class="col5">
            <div class="tabs-container" id="assetTabs">
              <button class="tab-btn active" data-target="headGrid">頭部</button>
              <button class="tab-btn" data-target="bodyGrid">身體</button>
              <button class="tab-btn" data-target="bgGrid">背景</button>
              <button class="tab-btn" data-target="addon1Grid">Addon 1</button>
              <button class="tab-btn" data-target="addon2Grid">Addon 2</button>
            </div>
            <div class="grid">
              <div class="col12">
                <div class="picker-section active" id="headSection"><div id="headGrid" class="asset-grid"><div class="asset-spacer"></div></div></div>
              </div>
              <div class="col12">
                <div class="picker-section" id="bodySection"><div id="bodyGrid" class="asset-grid"><div class="asset-spacer"></div></div></div>
              </div>
              <div class="col12">
                <div class="picker-section" id="bgSection"><div id="bgGrid" class="asset-grid"><div class="asset-spacer"></div></div></div>
              </div>
              <div class="col12">
                <div class="picker-section" id="addon1Section"><div id="addon1Grid" class="asset-grid"><div class="asset-spacer"></div></div></div>
                <div class="picker-section" id="addon2Section"><div id="addon2Grid" class="asset-grid"><div class="asset-spacer"></div></div></div>
              </div>
            </div>
            <div class="hr"></div>
            <a class="btn" href="recipes.html">去看成品庫</a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="app.js"></script>

<script>
  (async function(){
    await initSession();
    q("#netBadge").textContent = APP.offline ? "Offline" : "Online";

    // --- Tab Logic ---
    const tabBtns = document.querySelectorAll('.tab-btn');
    const sections = document.querySelectorAll('.picker-section');
    
    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = btn.getAttribute('data-target');
        const targetSectionId = targetId.replace('Grid', 'Section');
        
        tabBtns.forEach(b => b.classList.remove('active'));
        sections.forEach(s => s.classList.remove('active'));
        
        btn.classList.add('active');
        document.getElementById(targetSectionId).classList.add('active');
        
        // Trigger rerender for virtual grid when tab switches
        const gridKey = targetId.replace('Grid', '');
        if(grids[gridKey]) grids[gridKey].rerender();
      });
    });

function toThumbUrl(url){
  if(!url) return "";
  if(url.includes("_thumb.")) return url;
  const parts = String(url).split("?");
  const base = parts[0];
  const qs = parts.length > 1 ? "?" + parts.slice(1).join("?") : "";
  const m = base.match(/^(.*)\.(png|webp|jpg|jpeg)$/i);
  if(!m) return url;
  return m[1] + "_thumb." + m[2] + qs;
}
function bestThumb(url){
  const t = toThumbUrl(url);
  return t || url || "";
}


const TRANSPARENT_GIF = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";

window.showLevelUpFx = function showLevelUpFx(){
  const fx = q("#levelUpFx");
  if(!fx) return;
  fx.classList.add("active");
  clearTimeout(fx._t);
  fx._t = setTimeout(()=>{
// Worker base fallback (if app.js did not define it)
if(typeof WORKER_BASE === "undefined" || !WORKER_BASE){
  window.WORKER_BASE = "https://acf-api.dream-league-baseball.workers.dev";
}
 fx.classList.remove("active"); }, 1050);
};



function normId(v){
  if(v === null || v === undefined) return "";
  return String(v).trim();
}

function normAddonPair(a1, a2){
  const ids = [normId(a1), normId(a2)].filter(Boolean);
  ids.sort();
  return ids;
}

async function ensureRecipesLoaded(){
  if(db.recipes && db.recipes.length) return true;
  try{
    const res = await api("/api/recipes");
    if(res && Array.isArray(res.recipes)){
      db.recipes = res.recipes;
      return true;
    }
  }catch(e){}
  return !!(db.recipes && db.recipes.length);
}

function recipeMatchesPayloadRow(recipe, payload){
  if(!recipe) return false;
  if(normId(recipe.headId) !== normId(payload.headId)) return false;
  if(normId(recipe.bodyId) !== normId(payload.bodyId)) return false;
  if(normId(recipe.bgId) !== normId(payload.bgId)) return false;

  const ra = normAddonPair(recipe.addon1Id, recipe.addon2Id);
  const pa = normAddonPair(payload.addon1Id, payload.addon2Id);

  if(ra.length !== pa.length) return false;
  for(let i=0;i<ra.length;i++){
    if(ra[i] !== pa[i]) return false;
  }
  return true;
}

function findMatchingRecipeIdsFromRows(payload){
  const rs = (db.recipes || []);
  const ids = [];
  for(const r of rs){
    if(recipeMatchesPayloadRow(r, payload)) ids.push(r.recipeId);
  }
  return ids;
}

async function unlockRecipeOnline(recipeId){
  try{
    const res = await api("/api/unlock", {
      method:"POST",
      body: JSON.stringify({ recipeId })
    });
    return res;
  }catch(e){
    return null;
  }
}

function unlockRecipeOffline(recipeId){
  const db2 = offlineDb();
  db2.unlocks = db2.unlocks || {};
  db2.unlocks[`${APP.uid}:${recipeId}`] = Date.now();
  saveOfflineDb(db2);
  // keep in-memory db in sync too
  db.unlocks = db.unlocks || {};
  db.unlocks[`${APP.uid}:${recipeId}`] = db2.unlocks[`${APP.uid}:${recipeId}`];
}



function setImgWithFallback(imgEl, primaryUrl, fallbackUrl) {
  if(!imgEl) return;
  const primary = String(primaryUrl || "");
  const fallback = String(fallbackUrl || "");
  imgEl.dataset._fallback = fallback;
  imgEl.dataset._triedFallback = "0";
  imgEl.onload = () => {
    try{
      const st = q(".stage");
      if(st && imgEl.naturalWidth && imgEl.naturalHeight){
        st.style.setProperty("--stageW", imgEl.naturalWidth + "px");
        st.style.setProperty("--stageH", imgEl.naturalHeight + "px");
      }
    }catch(e){}
  };
  imgEl.onerror = () => {
    // Try fallback once (thumb -> original), then hide/clear
    if(imgEl.dataset._triedFallback !== "1" && imgEl.dataset._fallback) {
      imgEl.dataset._triedFallback = "1";
      imgEl.src = imgEl.dataset._fallback;
      return;
    }
    imgEl.onerror = null;
    imgEl.src = TRANSPARENT_GIF;
  };
  imgEl.src = primary || fallback || TRANSPARENT_GIF;
}
function listImgUrl(it){
  const id = (it && it.assetId) ? String(it.assetId) : "";
  const url = (it && it.imageUrl) ? String(it.imageUrl) : "";
  if(id.startsWith("head_") || id.startsWith("body_")) return toThumbUrl(url) || url;
  return url;
}

function genderTag(assetId){
  const id = String(assetId || "").toLowerCase();
  if(id.includes("f")) return "f";
  if(id.includes("m")) return "m";
  return "";
}

function isGenderCompatible(headId, bodyId){
  const headGender = genderTag(headId);
  const bodyGender = genderTag(bodyId);
  if(!headGender || !bodyGender) return true;
  return headGender === bodyGender;
}

// --- Star & Count Logic ---
function getAssetStats(assetId, count, starsFromDb) {
  let stars = Number(starsFromDb || 0);
  if(!Number.isFinite(stars) || stars < 1) stars = 1;
  if(stars > 5) stars = 5;

  const neededForNext = (stars >= 5) ? "MAX" : (stars * 10);
  return { stars, neededForNext, totalCount: Number(count || 0) };
}


    let db = offlineDb();

if(!APP.offline){
  try{
    const assetsRes = await fetch(WORKER_BASE + "/api/assets").then(r=>r.json());
    const rawAssets = assetsRes.assets || assetsRes.items || assetsRes.rows || assetsRes.results || [];
    const assets = (rawAssets || []).map(a=>{
      const t = String(a.type || "");
      let type = t;
      if(t === "bg") type = "background";
      if(t === "addon1" || t === "addon2") type = "accessory";
      if(t === "backgrounds") type = "background";
      return { assetId: a.assetId, type, rarity: Number(a.rarity||1), imageUrl: a.imageUrl };
    });

    const invRes = await fetch(WORKER_BASE + "/api/me/assets?uid=" + encodeURIComponent(APP.uid)).then(r=>r.json());
    const items = invRes.items || invRes.assets || invRes.rows || invRes.results || [];
    const storeCount = {};
    const storeStars = {};
    for(const it of (items || [])){
      const aid = it.assetId || it.asset_id || it.id;
      if(!aid) continue;
      storeCount[`${APP.uid}:${aid}`] = Number(it.count || it.qty || 1);
      const s = it.stars;
      if(s !== undefined && s !== null && s !== "") storeStars[`${APP.uid}:${aid}`] = Number(s);
    }

    db = { assets, userAssets: storeCount, userStars: storeStars, unlocks: {} };
  }catch(e){
    db = offlineDb();
  }
}

    const byId = new Map(db.assets.map(a=>[a.assetId,a]));

    // refresh counts/stars from DB after upgrade
    window.reloadInventory = async function reloadInventory(){
      if(APP.offline) return;
      const invRes = await fetch(WORKER_BASE + "/api/me/assets?uid=" + encodeURIComponent(APP.uid)).then(r=>r.json());
      const items = invRes.items || invRes.assets || invRes.rows || invRes.results || [];
      const storeCount = {};
      const storeStars = {};
      for(const it of (items || [])){
        const aid = it.assetId || it.asset_id || it.id;
        if(!aid) continue;
        storeCount[`${APP.uid}:${aid}`] = Number(it.count || it.qty || 0);
        const s = it.stars;
        if(s !== undefined && s !== null && s !== "") storeStars[`${APP.uid}:${aid}`] = Number(s);
      }
      db.userAssets = storeCount;
      db.userStars = storeStars;
      enforceRarityAfterHeadChange();
      Object.values(grids).forEach(g=>g && g.rerender && g.rerender());
    };

    async function saveOnline(payload){
      try{
        const res = await api("/api/save", {
          method: "POST",
          body: JSON.stringify(payload)
        });
        if(res && res.ok) return res;
        return res || null;
      }catch(e){
        return null;
      }
    }

    async function saveOffline(payload){
      const db2 = offlineDb();
      const id = crypto.randomUUID();
      const savedOn = Date.now();
      const row = {
        id,
        userId: APP.uid,
        headId: payload.headId,
        bodyId: payload.bodyId,
        bgId: payload.bgId,
        addon1Id: payload.addon1Id || "",
        addon2Id: payload.addon2Id || "",
        savedOn
      };
      db2.saves = db2.saves || [];
      db2.saves.unshift(row);
      saveOfflineDb(db2);
      return { ok:true, id, savedOn };
    }

    function showUnlock(ids){
      const el = q("#unlockHint");
      if(!el) return;
      el.textContent = (!ids || ids.length === 0) ? "沒有觸發成品解鎖" : `已解鎖成品 ${ids.join("  ")}`;
    }

    function invCount(assetId){
      const k = `${APP.uid}:${assetId}`;
      const store = db.userAssets || db.playerAssets || db.assetsOwned || {};
      return Number(store[k] || store[assetId] || 0);
    }

    function ownedOptions(type){
      const list = db.assets.filter(a=>a.type===type && invCount(a.assetId) > 0);
      list.sort(byRarityDesc);
      return list;
    }

const SEL = { headId: "", bodyId: "", bgId: "", addon1Id: "", addon2Id: "" };

const unlockedAssetIds = new Set();
for(const key of Object.keys(db.unlocks || {})){
  if(!key.startsWith(APP.uid + ":")) continue;
  const recipeId = key.split(":")[1];
  const r = (db.recipes || []).find(x=>x.recipeId === recipeId);
  if(!r) continue;
  [r.headId, r.bodyId, r.bgId, ...(r.accessoryIds||[])].filter(Boolean).forEach(id => unlockedAssetIds.add(id));
}

function invStars(assetId){
  return Number(db.userStars?.[`${APP.uid}:${assetId}`] ?? 0);
}

const RARITY_LABEL = {1:"C",2:"R",3:"SR",4:"SSR",5:"UR"};

function clampStars(n){
  let s = Number(n || 0);
  if(!Number.isFinite(s) || s < 1) s = 1;
  if(s > 5) s = 5;
  return s;
}

// Effective rarity = base rarity + (stars - 1), capped at 5
function effectiveRarityById(assetId){
  if(!assetId) return 0;
  const base = (typeof getBaseRarityById === 'function' ? (getBaseRarityById(assetId) || 1) : Number(byId.get(assetId)?.rarity || 1));
  const stars = clampStars(invStars(assetId));
  return Math.min(5, base + (stars - 1));
}

function getBaseRarityById(assetId){
  if(!assetId) return 0;
  const fromMap = Number(byId.get(assetId)?.rarity || 0);
  if(fromMap) return fromMap;
  const parts = String(assetId).split("_");
  const n = Number(parts[1] || 0);
  return Number.isFinite(n) && n >= 1 ? n : 0;
}

function getHeadRule(){
  if(!SEL.headId) return { base: 0, max: 0 };
  const base = Number(byId.get(SEL.headId)?.rarity || 1);
  const stars = clampStars(invStars(SEL.headId));
  const max = Math.min(5, base + (stars - 1));
  return { base, max };
}

// Compatibility rules (stars increase possibilities, not restrictions)
// 1) Same or higher base rarity allowed up to head max tier (regardless of their stars)
// 2) Lower base rarity allowed only if that item is upgraded enough to reach head base tier
function isCompatibleWithHead(candidateId){
  if(!candidateId) return true;
  const rule = getHeadRule();
  if(!rule.base) return true;

  const base = Number(byId.get(candidateId)?.rarity || 1);
  const maxEff = effectiveRarityById(candidateId);

  if(base >= rule.base && base <= rule.max) return true;
  if(base < rule.base && maxEff >= rule.base) return true;

  return false;
}

function ruleHintText(){
  const r = getHeadRule();
  if(!r.base) return "";
  return `可搭配 ${RARITY_LABEL[r.base] || "C"} 至 ${RARITY_LABEL[r.max] || "C"}（較低等級需升星補足到 ${RARITY_LABEL[r.base] || "C"}）`;
}

function setLayers(){
  const bgUrl = byId.get(SEL.bgId)?.imageUrl || "";
  const a2Url = byId.get(SEL.addon2Id)?.imageUrl || "";
  const hUrl = byId.get(SEL.headId)?.imageUrl || "";
  const bUrl = byId.get(SEL.bodyId)?.imageUrl || "";
  const a1Url = byId.get(SEL.addon1Id)?.imageUrl || "";

  // Stage layers: if empty or failed to load, use transparent and hide the layer so no broken icon shows
  const bgEl = q("#bgLayer");
  const a2El = q("#addon2Layer");
  const hEl  = q("#headLayer");
  const bEl  = q("#bodyLayer");
  const a1El = q("#addon1Layer");

  const setStage = (el, primary, fallback) => {
    if(!el) return;
    if(!primary){
      el.src = TRANSPARENT_GIF;
      el.style.display = "none";
      el.onerror = null;
      return;
    }
    el.style.display = "block";
    el.onerror = () => {
      el.onerror = null;
      el.src = TRANSPARENT_GIF;
      el.style.display = "none";
    };
    el.src = primary || fallback || TRANSPARENT_GIF;
  };

  setStage(bgEl, bgUrl, "");
  setStage(a2El, a2Url, "");
  setStage(hEl,  hUrl,  "");
  setStage(bEl,  bUrl,  "");
  setStage(a1El, a1Url, "");

  // body missing mask: hide parts that should be covered by body
  const maskEl = q("#bodyMissingMask");
  if(maskEl){
    maskEl.style.display = SEL.bodyId ? "none" : "block";
  }
}


function refreshPreview(){ setLayers(); }

const hoverBox = q("#hoverPreview");
const hoverImg = hoverBox.querySelector("img");
function showHover(src, x, y){
  const s = String(src || "");
  if(!s){ hideHover(); return; }
  hoverImg.onerror = ()=>{ hideHover(); };
  hoverImg.src = s;
  hoverBox.style.display = "block";
  moveHover(x, y);
}
function moveHover(x, y){
  const pad = 16;
  const w = hoverBox.offsetWidth || 213;
  const h = hoverBox.offsetHeight || 320;
  let left = x + pad;
  let top = y + pad;
  if(left + w > window.innerWidth - 8) left = x - w - pad;
  if(top + h > window.innerHeight - 8) top = y - h - pad;
  hoverBox.style.left = left + "px";
  hoverBox.style.top = top + "px";
}
function hideHover(){ hoverBox.style.display = "none"; hoverImg.src = ""; }

function makeVirtualGrid(container, items0, getSelectedId, onSelect, options){
  let items = items0 || [];
  const opt = Object.assign({thumbW:64, thumbH:96, gap:8}, options || {});
  const spacer = container.querySelector(".asset-spacer") || container;
  
  function calcCols(){
    return Math.max(1, Math.floor((container.clientWidth + opt.gap) / (opt.thumbW + opt.gap)));
  }

  function rerender(){
    const cols = calcCols();
    const rowH = opt.thumbH + opt.gap;
    const rows = Math.ceil(items.length / cols);
    spacer.style.height = (rows * rowH) + "px";
    spacer.style.position = "relative";
    const scrollTop = container.scrollTop;
    const viewH = container.clientHeight;
    const startRow = Math.max(0, Math.floor(scrollTop / rowH) - 2);
    const endRow = Math.min(rows, Math.ceil((scrollTop + viewH) / rowH) + 2);
    spacer.innerHTML = "";

    for(let r = startRow; r < endRow; r++){
      for(let c = 0; c < cols; c++){
        const idx = r * cols + c;
        if(idx >= items.length) break;
        const it = items[idx];
        const wrap = document.createElement("div");
        const baseR = it.assetId ? (typeof getBaseRarityById === 'function' ? (getBaseRarityById(it.assetId) || 1) : Number(byId.get(it.assetId)?.rarity || 1)) : Number(it.rarity || 1);
        wrap.className = "asset-item " + `r${baseR || 1}`;
        if(it._disabled) wrap.classList.add("disabled");
        if(it.assetId) wrap.setAttribute("data-asset-id", String(it.assetId));
        wrap.style.left = (c * (opt.thumbW + opt.gap)) + "px";
        wrap.style.top = (r * rowH) + "px";

        const img = document.createElement("img");
        img.className = "asset-thumb";
        const primarySrc = listImgUrl(it) || "";
const fallbackSrc = (it && it.imageUrl) ? String(it.imageUrl) : "";
if(!primarySrc && !fallbackSrc){
  img.src = TRANSPARENT_GIF;
}else{
  img.src = primarySrc || fallbackSrc || TRANSPARENT_GIF;
}
img.dataset._fallbackThumb = fallbackSrc;
img.dataset._triedFallbackThumb = "0";
img.addEventListener("error", ()=>{
  // head/body: if thumb missing, fallback to original; otherwise use transparent
  if(img.dataset._triedFallbackThumb !== "1" && fallbackSrc && (String(it.assetId||"").startsWith("head_") || String(it.assetId||"").startsWith("body_"))){
    img.dataset._triedFallbackThumb = "1";
    img.src = fallbackSrc;
    return;
  }
  img.src = TRANSPARENT_GIF;
});
        if(getSelectedId() === it.assetId) img.classList.add("active");

        img.addEventListener("click", ()=>{ onSelect(it.assetId); rerender(); });
        img.addEventListener("mouseenter", (e)=>{
          const hs = (listImgUrl(it) || (it && it.imageUrl) || "");
          if(!hs) return;
          showHover(hs, e.clientX, e.clientY);
        });
        img.addEventListener("mousemove", (e)=>moveHover(e.clientX, e.clientY));
        img.addEventListener("mouseleave", hideHover);
        wrap.appendChild(img);

        // --- Stats Badges ---
        if(it.assetId) {
          const count = invCount(it.assetId);
          const stats = getAssetStats(it.assetId, count, invStars(it.assetId));
          const neededNum = (stats.stars >= 5) ? null : (stats.stars * 10);
          const canUpgrade = !!neededNum && stats.totalCount >= neededNum;
          
          // Count Badge (Top Right)
          const cBadge = document.createElement("div");
          cBadge.className = "badge-count";
          cBadge.textContent = `${stats.totalCount}/${stats.neededForNext}`;
          if(stats.stars >= 5) cBadge.classList.add("gray");
          else if(canUpgrade) cBadge.classList.add("ready");
          else cBadge.classList.add("notready");
          wrap.appendChild(cBadge);

          // Rarity Badge (Top Left) show only when not using thumb image
          const imgSrc = String(it.imageUrl || "");
          if(imgSrc && !imgSrc.includes("_thumb")){
            const rBadge = document.createElement("div");
            rBadge.className = "badge-rarity";
            const rMap = {1:"C",2:"R",3:"SR",4:"SSR",5:"UR"};
            const r = it.assetId ? (typeof getBaseRarityById === 'function' ? (getBaseRarityById(it.assetId) || 1) : Number(byId.get(it.assetId)?.rarity || 1)) : Number(it.rarity || 1);
            rBadge.textContent = rMap[r] || "C";
            wrap.appendChild(rBadge);
          }
          
          // Star Badge (Bottom Left)
          const sBadge = document.createElement("div");
          sBadge.className = "badge-stars";
          sBadge.textContent = "★".repeat(stats.stars);
          
          wrap.appendChild(sBadge);

          // Upgrade overlay
          if(canUpgrade){
            const ov = document.createElement("div");
            ov.className = "upgrade-overlay";
            const label = document.createElement("span");
            label.textContent = "可升級";
            ov.appendChild(label);
            ov.addEventListener("click", async (e)=>{
              e.preventDefault();
              e.stopPropagation();
              await doUpgrade(it.assetId);
              rerender();
            });
            wrap.appendChild(ov);
          }
        }

        if(unlockedAssetIds.has(it.assetId)){
          const b = document.createElement("div");
          b.className = "badge-unlocked";
          b.textContent = "✓";
          wrap.appendChild(b);
        }
        spacer.appendChild(wrap);
      }
    }
  }
  container.addEventListener("scroll", rerender);
  window.addEventListener("resize", rerender);
  rerender();
  return { rerender, setItems: (next)=>{ items = Array.isArray(next) ? next : []; container.scrollTop = 0; rerender(); } };
}

const grids = {};
const headItemsAll = ownedOptions("head");
let headItems = headItemsAll;
const bodyItemsAll = ownedOptions("body");
let bodyItems = bodyItemsAll;
const bgItemsAll = ownedOptions("background");
let bgItems = bgItemsAll;

SEL.headId = headItems[0]?.assetId || "";
SEL.bodyId = bodyItems[0]?.assetId || "";

function applyBodyGenderRule(){
  const headGender = genderTag(SEL.headId);
  let filtered = bodyItemsAll;

  if(headGender){
    filtered = filtered.filter(it => {
      const bodyGender = genderTag(it.assetId);
      return !bodyGender || bodyGender === headGender;
    });
  }

  filtered = filtered.map(it => ({...it, _disabled: !isCompatibleWithHead(it.assetId)}));
bodyItems = filtered.length > 0 ? filtered : bodyItemsAll;

  // keep selection valid
  if(SEL.bodyId && !bodyItems.some(it=>it.assetId === SEL.bodyId)){
    SEL.bodyId = bodyItems[0]?.assetId || "";
  }
  if(grids.body) grids.body.setItems(bodyItems);
}

function applyBgRarityRule(){
  const filtered = bgItemsAll.map(it => ({...it, _disabled: !isCompatibleWithHead(it.assetId)}));
  bgItems = filtered.length ? filtered : bgItemsAll;
  if(SEL.bgId && !bgItems.some(it=>it.assetId === SEL.bgId)){
    SEL.bgId = bgItems[0]?.assetId || "";
  }
  if(grids.bg) grids.bg.setItems(bgItems);
}

function applyAddonRarityRule(){
  const filterOne = (pool) => pool.map(it => ({...it, _disabled: !!it.assetId && !isCompatibleWithHead(it.assetId)}));

  addon1Pool = filterOne(addon1PoolAll);
  addon2Pool = filterOne(addon2PoolAll);

  if(SEL.addon1Id && !addon1Pool.some(it=>it.assetId === SEL.addon1Id)) SEL.addon1Id = "";
  if(SEL.addon2Id && !addon2Pool.some(it=>it.assetId === SEL.addon2Id)) SEL.addon2Id = "";

  if(grids.addon1) grids.addon1.setItems([noneItem, ...addon1Pool]);
  if(grids.addon2) grids.addon2.setItems([noneItem, ...addon2Pool]);
}

function enforceRarityAfterHeadChange(){
  const r = getHeadRule();
  if(!r.base) return;

  // reset incompatible selections
  if(SEL.bodyId && !isCompatibleWithHead(SEL.bodyId)) SEL.bodyId = "";
  if(SEL.bgId && !isCompatibleWithHead(SEL.bgId)) SEL.bgId = "";
  if(SEL.addon1Id && !isCompatibleWithHead(SEL.addon1Id)) SEL.addon1Id = "";
  if(SEL.addon2Id && !isCompatibleWithHead(SEL.addon2Id)) SEL.addon2Id = "";

  applyBodyGenderRule();
  applyBgRarityRule();
  applyAddonRarityRule();
}

function canSelectSameRarity(newAssetId){
  if(!newAssetId) return true;
  if(!isCompatibleWithHead(newAssetId)){
    toast(ruleHintText() || "素材不匹配");
    return false;
  }
  return true;
}
applyBodyGenderRule();

const addonAll = ownedOptions("accessory");
const byPrefix = (prefix) => addonAll.filter(a=>((a.imageUrl || "").split("/").pop() || "").startsWith(prefix));
let addon1Pool = byPrefix("addon1_");
let addon2Pool = byPrefix("addon2_");
if(addon1Pool.length === 0 && addon2Pool.length === 0){ addon1Pool = addonAll; addon2Pool = addonAll; }
else { if(addon1Pool.length === 0) addon1Pool = addonAll; if(addon2Pool.length === 0) addon2Pool = addonAll; }

const addon1PoolAll = addon1Pool.slice();
const addon2PoolAll = addon2Pool.slice();

const noneItem = { assetId:"", imageUrl:"", rarity:1 };

grids.head = makeVirtualGrid(q("#headGrid"), headItemsAll, ()=>SEL.headId, (id)=>{ SEL.headId=id; enforceRarityAfterHeadChange(); refreshPreview(); Object.values(grids).forEach(g=>g && g.rerender && g.rerender()); });
grids.body = makeVirtualGrid(q("#bodyGrid"), bodyItems, ()=>SEL.bodyId, (id)=>{ if(!canSelectSameRarity(id)) return; SEL.bodyId=id; refreshPreview(); });
grids.bg = makeVirtualGrid(q("#bgGrid"), bgItems, ()=>SEL.bgId, (id)=>{ if(!canSelectSameRarity(id)) return; SEL.bgId=id; refreshPreview(); });
grids.addon1 = makeVirtualGrid(q("#addon1Grid"), [noneItem, ...addon1Pool], ()=>SEL.addon1Id, (id)=>{ if(id && !canSelectSameRarity(id)) return; SEL.addon1Id=id; refreshPreview(); });
grids.addon2 = makeVirtualGrid(q("#addon2Grid"), [noneItem, ...addon2Pool], ()=>SEL.addon2Id, (id)=>{ if(id && !canSelectSameRarity(id)) return; SEL.addon2Id=id; refreshPreview(); });

enforceRarityAfterHeadChange();
refreshPreview();

q("#randomBtn").addEventListener("click", ()=>{
  const hAll = ownedOptions("head");
  const bAll = ownedOptions("body");
  const gAll = ownedOptions("background");
  if(hAll.length === 0 || bAll.length === 0 || gAll.length === 0) return toast("素材不足");

  // try a few times to find a compatible full set
  let picked = false;
  for(let tries=0; tries<25 && !picked; tries++){
    const h = randPick(hAll);
    const headBase = Number(byId.get(h.assetId)?.rarity || 1);
    const headStars = clampStars(invStars(h.assetId));
    const headMax = Math.min(5, headBase + (headStars - 1));
    const hGender = genderTag(h.assetId);

    const bCandidates = bAll.filter(it=>{
      if(hGender){
        const bg = genderTag(it.assetId);
        if(bg && bg !== hGender) return false;
      }
      const base = Number(byId.get(it.assetId)?.rarity || 1);
      const maxEff = effectiveRarityById(it.assetId);
      if(base >= headBase && base <= headMax) return true;
      if(base < headBase && maxEff >= headBase) return true;
      return false;
    });

    const gCandidates = gAll.filter(it=>{
      const base = Number(byId.get(it.assetId)?.rarity || 1);
      const maxEff = effectiveRarityById(it.assetId);
      if(base >= headBase && base <= headMax) return true;
      if(base < headBase && maxEff >= headBase) return true;
      return false;
    });

    if(bCandidates.length === 0 || gCandidates.length === 0) continue;

    SEL.headId = h.assetId;
    SEL.bodyId = randPick(bCandidates).assetId;
    SEL.bgId = randPick(gCandidates).assetId;

    // accessories: optional, must match target if selected
    const aAll = ownedOptions("accessory");
    const isOk = (id)=>{
      const base = Number(byId.get(id)?.rarity || 1);
      const maxEff = effectiveRarityById(id);
      if(base >= headBase && base <= headMax) return true;
      if(base < headBase && maxEff >= headBase) return true;
      return false;
    };
    const p1 = aAll.filter(a=> (a.imageUrl||"").split("/").pop().startsWith("addon1_") && isOk(a.assetId));
    const p2 = aAll.filter(a=> (a.imageUrl||"").split("/").pop().startsWith("addon2_") && isOk(a.assetId));
    SEL.addon1Id = (p1.length ? randPick([ {assetId:""}, ...p1 ]).assetId : "");
    SEL.addon2Id = (p2.length ? randPick([ {assetId:""}, ...p2 ]).assetId : "");

    picked = true;
  }

  if(!picked) return toast("找不到可搭配的同稀有度組合");

  enforceRarityAfterHeadChange();
  refreshPreview();
  Object.values(grids).forEach(g => g && g.rerender && g.rerender());
  toast("已隨機搭配");
});

q("#submitBtn").addEventListener("click", async ()=>{
  const payload = { headId: SEL.headId, bodyId: SEL.bodyId, bgId: SEL.bgId, addon1Id: SEL.addon1Id || "", addon2Id: SEL.addon2Id || "" };
  if(!payload.headId || !payload.bodyId || !payload.bgId) return toast("素材不足");
  if(!isGenderCompatible(payload.headId, payload.bodyId)) return toast("性別不匹配");
  const others = [payload.bodyId, payload.bgId, payload.addon1Id, payload.addon2Id].filter(Boolean);
  if(others.some(id => !isCompatibleWithHead(id))) return toast(ruleHintText() || "素材不匹配");
  toast("保存中");
  let data = await saveOnline(payload) || await saveOffline(payload);
  if(data && data.ok){
    toast("已保存");

    // check recipes -> unlock collection
    const okRecipes = await ensureRecipesLoaded();
    if(!okRecipes){
      // no recipe list available, skip unlock
    }
    const matchIds = okRecipes ? findMatchingRecipeIdsFromRows(payload) : [];
    const newlyUnlocked = [];
    for(const rid of matchIds){
      const key = `${APP.uid}:${rid}`;
      const already = !!(db.unlocks && db.unlocks[key]);
      if(already) continue;

      // write unlock (online first, fallback offline)
      const u = await unlockRecipeOnline(rid);
      if(!(u && u.ok)){
        unlockRecipeOffline(rid);
      }else{
        // also mirror locally so UI updates immediately
        db.unlocks = db.unlocks || {};
        db.unlocks[key] = Date.now();
      }
      newlyUnlocked.push(rid);
    }

    if(newlyUnlocked.length){
      if(window.showCollectionFx) window.showCollectionFx(newlyUnlocked);
    }
  }else{
    toast("保存失敗");
    console.log("save_failed", data);
  }
});
refreshPreview();
})();


async function doUpgrade(assetId){
  const uid = localStorage.getItem("acf_uid");
  const card = document.querySelector(`[data-asset-id='${assetId}']`);
  if(card) card.classList.add("upgrading");

  const res = await fetch(WORKER_BASE + "/api/upgrade", {
    method:"POST",
    headers:{ "content-type":"application/json", "x-user-id": uid },
    body: JSON.stringify({ uid, assetId })
  }).then(r=>r.json());

  if(res.ok){
    if(window.showLevelUpFx) window.showLevelUpFx();
    await reloadInventory();
  }else{
    alert(res.error || "upgrade failed");
  }

  if(card) card.classList.remove("upgrading");
}
</script>

<div id="hoverPreview"><img alt="preview"/></div>

<div id="levelUpFx">
  <div>
    <div class="levelUpCard">NEW LEVEL UNLOCKED</div>
    <div class="levelUpSub">Upgrade successful</div>
  </div>
</div>


<div id="collectionFx">
  <div>
    <div class="levelUpCard">NEW COLLECTION UNLOCKED!</div>
    <div class="levelUpSub" id="collectionFxSub"></div>
  </div>
</div>

</body>
</html>
