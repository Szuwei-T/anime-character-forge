<!DOCTYPE html>

<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title data-i18n="studio_title">工作室 - 進階版</title>
<link href="style.css" rel="stylesheet"/>
<link href="ui_fx.css" rel="stylesheet"/>
<style id="thumbStyle">
  .picker-section{margin-bottom:14px; display: none;}
  .picker-section.active{display: block;}
  .picker-title{font-size:14px;opacity:.9;margin:10px 0 10px; display: none;}
  
  /* Tabs Styling */
  .tabs-container {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
    overflow-x: auto;
    padding-bottom: 4px;
  }
  .tab-btn {
    padding: 8px 16px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
    white-space: nowrap;
    font-size: 13px;
    transition: all 0.2s;
  }
  .tab-btn.active {
    background: rgba(74,222,128,0.2);
    border-color: rgba(74,222,128,0.5);
    color: #4ade80;
  }

  .asset-grid{
    position: relative;
    height: 400px; /* Increased height for better tab view */
    overflow: auto;
    padding: 10px;
    border-radius: 16px;
    border: 1px solid rgba(255,255,255,0.10);
    background: rgba(0,0,0,0.12);
  }
  .asset-spacer{width:100%; position:relative;}
  .asset-item{
    position:absolute;
    width:64px;
    height:96px;
  }
  .asset-thumb{
    width:64px;
    height:96px;
    border-radius:12px;
    border:2px solid rgba(255,255,255,0.18);
    cursor:pointer;
    object-fit:contain;
    background: rgba(0,0,0,0.20);
    display:block;
  }
  .asset-thumb.active{outline:2px solid rgba(239,68,68,0.95); outline-offset:2px;}

  /* rarity borders */
  .r1 .asset-thumb{border-color: rgba(148,163,184,0.75);}
  .r2 .asset-thumb{border-color: rgba(34,197,94,0.75);}
  .r3 .asset-thumb{border-color: rgba(59,130,246,0.75);}
  .r4 .asset-thumb{border-color: rgba(168,85,247,0.75);}
  .r5 .asset-thumb{border-color: rgba(245,158,11,0.85);}

  /* Count Badge (Top Right) */
  .badge-count {
    position: absolute;
    right: -4px;
    top: -4px;
    background: rgba(0,0,0,0.75);
    color: #fff;
    font-size: 10px;
    padding: 2px 5px;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.2);
    z-index: 80;
    pointer-events: none;
  }

  /* upgrade-ready / not-ready styling for count badge */
  .badge-count.ready{
    background: rgba(250,204,21,0.90);
    color: #111827;
    border-color: rgba(250,204,21,0.95);
    box-shadow: 0 0 0 1px rgba(250,204,21,0.55), 0 10px 20px rgba(0,0,0,0.35);
  }
  .badge-count.notready{
    background: rgba(0,0,0,0.75);
    color: rgba(239,68,68,0.95);
    border-color: rgba(239,68,68,0.45);
  }
  .badge-count.gray{
    background: rgba(0,0,0,0.75);
    color: rgba(148,163,184,0.95);
    border-color: rgba(148,163,184,0.35);
  }

  /* upgrade overlay */
  .upgrade-overlay{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    border-radius:12px;
    background: rgba(0,0,0,0.45);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index: 40;
    cursor: pointer;
      pointer-events: auto;
  }
  .upgrade-overlay span{
    font-size: 12px;
    font-weight: 800;
    padding: 6px 10px;
    border-radius: 999px;
    background: rgba(250,204,21,0.92);
    color: #111827;
    border: 1px solid rgba(250,204,21,0.95);
    box-shadow: 0 10px 24px rgba(0,0,0,0.45);
  }

  /* upgrade animation */
  .asset-item.upgrading .asset-thumb{
    animation: upgradePulse 650ms ease-in-out 1;
  }
  .asset-item.upgrading{
    filter: drop-shadow(0 0 10px rgba(250,204,21,0.55));
  }
  @keyframes upgradePulse{
    0%{ transform: scale(1); }
    35%{ transform: scale(1.06); }
    70%{ transform: scale(0.99); }
    100%{ transform: scale(1); }
  }

  /* Rarity Badge (Top Left) */
  .badge-rarity{
    position:absolute;
    left:-4px;
    top:-4px;
    background: rgba(0,0,0,0.75);
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.12);
    z-index: 80;
    pointer-events:none;
    font-weight: 700;
    letter-spacing: 0.5px;
  }
  .r1 .badge-rarity{ color: rgba(148,163,184,0.95); border-color: rgba(148,163,184,0.6); }
  .r2 .badge-rarity{ color: rgba(34,197,94,0.95); border-color: rgba(34,197,94,0.6); }
  .r3 .badge-rarity{ color: rgba(59,130,246,0.95); border-color: rgba(59,130,246,0.6); }
  .r4 .badge-rarity{ color: rgba(168,85,247,0.95); border-color: rgba(168,85,247,0.6); }
  .r5 .badge-rarity{ color: rgba(245,158,11,0.98); border-color: rgba(245,158,11,0.7); }

  /* Star Badge (Bottom Right) */
  .badge-stars {
    position: absolute;
    right: 4px;
    bottom: 4px;
    color: #fbbf24;
    font-size: 13px;
    font-weight: 700;
    background: rgba(0,0,0,0.65);
    border: 1px solid rgba(255,255,255,0.18);
    padding: 2px 6px;
    border-radius: 8px;
    text-shadow: 0 0 4px rgba(0,0,0,0.9);
    z-index: 80;
    pointer-events: none;
  }

  /* unlocked tick */
  .badge-unlocked{
    position:absolute;
    right: 20px; /* Shifted to avoid overlap with count */
    top:-6px;
    width:18px;
    height:18px;
    border-radius:999px;
    background: rgba(34,197,94,0.95);
    color:#04130a;
    font-weight:800;
    font-size:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    pointer-events:none;
    z-index: 3;
  }

  /* hover preview */
  #hoverPreview{
    position: fixed;
    z-index: 9999;
    width: 213px;
    height: 320px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(10px);
    display:none;
    overflow:hidden;
    pointer-events:none;
    box-shadow: 0 24px 70px rgba(0,0,0,0.55);
  }
  #hoverPreview img{
    width:100%;
    height:100%;
    object-fit:contain;
  }

  /* Star badge tweak: slightly smaller, shift right/down for 5 stars */
  .badge-stars{
    font-size: 11px;
    padding: 2px 4px;
    right: 2px;
    bottom: 2px;
    letter-spacing: -0.8px;
    transform: translate(2px, 2px);
  }

  /* Body-missing mask to hide parts that should be covered by body */
  .body-missing-mask{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    pointer-events:none;
    display:none;
    z-index: 50;
    border-radius: 18px;
    background: linear-gradient(
      to bottom,
      rgba(0,0,0,0.00) 0%,
      rgba(0,0,0,0.00) 22%,
      rgba(0,0,0,0.45) 28%,
      rgba(0,0,0,0.62) 100%
    );
    backdrop-filter: blur(1px);
  }

  /* Level up FX */
  #levelUpFx{
    position: fixed;
    inset: 0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index: 10000;
    pointer-events:auto;
    background:
      radial-gradient(circle at 50% 35%, rgba(255,255,255,0.12), rgba(0,0,0,0.78) 55%, rgba(0,0,0,0.92) 100%);
    backdrop-filter: blur(4px);
  }
  #levelUpFx.active{ display:flex; }

  /* Big, colorful, obvious pop */
  .levelUpCardWrap{
    position: relative;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:14px;
    pointer-events:auto;
    padding: 26px 28px 22px;
    border-radius: 22px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(0,0,0,0.58);
    box-shadow:
      0 40px 140px rgba(0,0,0,0.70),
      0 0 0 1px rgba(255,255,255,0.08) inset;
    transform-origin: center;
    animation: levelUpWrapPop 560ms ease-out 1, levelUpWrapFloat 2200ms ease-in-out infinite;
    overflow:hidden;
  }

  /* Neon particle layer */
  .levelUpCardWrap::before{
    content:"";
    position:absolute;
    inset:-60%;
    background-image:
      radial-gradient(circle, rgba(255,255,255,0.85) 2px, transparent 2.6px),
      radial-gradient(circle, rgba(255,215,0,0.85) 2px, transparent 2.6px),
      radial-gradient(circle, rgba(0,229,255,0.78) 2px, transparent 2.6px),
      radial-gradient(circle, rgba(255,0,255,0.60) 2px, transparent 2.6px);
    background-size: 88px 88px, 110px 110px, 96px 96px, 140px 140px;
    opacity: 0.55;
    filter: blur(0.2px);
    animation: levelUpParticlesSpin 2400ms linear infinite;
    pointer-events:none;
  }

  /* Burst ring */
  .levelUpCardWrap::after{
    content:"";
    position:absolute;
    width: 520px;
    height: 520px;
    border-radius: 999px;
    border: 2px solid rgba(255,255,255,0.10);
    box-shadow:
      0 0 30px rgba(255,255,255,0.10),
      0 0 120px rgba(255,215,0,0.12),
      0 0 160px rgba(0,229,255,0.12);
    opacity: 0.75;
    transform: scale(0.78);
    animation: levelUpRing 1200ms ease-out 1;
    pointer-events:none;
  }

  #levelUpFx .levelUpCard{
    position:relative;
    z-index: 2;
    padding: 6px 10px;
    border-radius: 14px;
    font-weight: 950;
    letter-spacing: 2px;
    text-transform: uppercase;
    font-size: 34px;
    text-align:center;
    line-height: 1.08;

    /* animated gradient text */
    background: linear-gradient(90deg,#ffdf00,#ff6a00,#ff00ff,#00e5ff,#00ff9c,#ffdf00);
    background-size: 420% 420%;
    -webkit-background-clip: text;
    color: transparent;

    /* strong glow */
    text-shadow:
      0 0 18px rgba(255,255,255,0.24),
      0 0 42px rgba(255,215,0,0.32),
      0 0 62px rgba(0,229,255,0.22);
    animation: levelUpGradient 1600ms linear infinite, levelUpTextPulse 1100ms ease-in-out infinite;
  }

  #levelUpFx .levelUpSub{
    position:relative;
    z-index: 2;
    margin-top: -2px;
    font-size: 30px;
    font-weight: 900;
    letter-spacing: 1px;
    opacity: 0.98;
    text-align:center;
    padding: 6px 14px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(0,0,0,0.35);
    box-shadow: 0 16px 48px rgba(0,0,0,0.40);
  }

  /* X => Y rarity coloring */
  #levelUpRange{ line-height: 1; }
  #levelUpRange .rarity{
    display:inline-block;
    min-width: 56px;
    padding: 2px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(0,0,0,0.25);
    transform: translateZ(0);
  }
  #levelUpRange .rar-arrow{
    display:inline-block;
    margin: 0 10px;
    font-weight: 950;
    opacity: 0.95;
    text-shadow: 0 0 16px rgba(255,255,255,0.18);
  }

  /* C green */
  #levelUpRange .rar-C{ color: rgba(34,197,94,1); text-shadow: 0 0 18px rgba(34,197,94,0.55), 0 0 44px rgba(34,197,94,0.25); }
  /* R blue */
  #levelUpRange .rar-R{ color: rgba(59,130,246,1); text-shadow: 0 0 18px rgba(59,130,246,0.55), 0 0 44px rgba(59,130,246,0.25); }
  /* SR purple */
  #levelUpRange .rar-SR{ color: rgba(168,85,247,1); text-shadow: 0 0 18px rgba(168,85,247,0.55), 0 0 44px rgba(168,85,247,0.25); }
  /* SSR orange */
  #levelUpRange .rar-SSR{ color: rgba(245,158,11,1); text-shadow: 0 0 18px rgba(245,158,11,0.55), 0 0 44px rgba(245,158,11,0.25); }

  /* UR red diamond sparkle */
  #levelUpRange .rar-UR{
    background: rgba(0,0,0,0.22);
  }
  #levelUpRange .rar-UR{
    background-image:
      linear-gradient(90deg, rgba(255,35,35,1), rgba(255,130,130,1), rgba(255,255,255,1), rgba(255,35,35,1));
    background-size: 300% 300%;
    -webkit-background-clip: text;
    color: transparent;
    text-shadow:
      0 0 20px rgba(255,35,35,0.55),
      0 0 56px rgba(255,35,35,0.30),
      0 0 90px rgba(255,255,255,0.18);
    animation: urShimmer 900ms linear infinite;
    border-color: rgba(255,35,35,0.35);
    box-shadow:
      0 0 0 1px rgba(255,35,35,0.18) inset,
      0 0 22px rgba(255,35,35,0.22),
      0 0 70px rgba(255,35,35,0.12);
  }
  @keyframes urShimmer{
    0%{ background-position: 0% 50%; filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
    60%{ filter: drop-shadow(0 0 10px rgba(255,255,255,0.22)); }
    100%{ background-position: 100% 50%; filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
  }

  #levelUpConfirm{
    position:relative;
    z-index: 2;
    margin-top: 6px;
    padding: 14px 58px;
    font-size: 20px;
    font-weight: 950;
    letter-spacing: 1px;
    border:none;
    border-radius: 999px;
    cursor:pointer;
    color:#081018;
    background: linear-gradient(90deg,#ffdf00,#ff6a00,#ff00ff,#00e5ff);
    background-size: 220% 220%;
    box-shadow:
      0 0 24px rgba(255,215,0,0.30),
      0 0 70px rgba(255,106,0,0.22),
      0 18px 50px rgba(0,0,0,0.40);
    transition: transform 0.12s ease;
    animation: levelUpGradient 1400ms linear infinite;
  }
  #levelUpConfirm:hover{ transform: scale(1.05); }
  #levelUpConfirm:active{ transform: scale(0.98); }

  @keyframes levelUpWrapPop{
    0%{ transform: translateY(22px) scale(0.86); opacity: 0; }
    55%{ transform: translateY(0) scale(1.04); opacity: 1; }
    100%{ transform: translateY(0) scale(1); opacity: 1; }
  }
  @keyframes levelUpWrapFloat{
    0%{ transform: translateY(0) scale(1); }
    50%{ transform: translateY(-4px) scale(1.005); }
    100%{ transform: translateY(0) scale(1); }
  }
  @keyframes levelUpParticlesSpin{
    0%{ transform: rotate(0deg) scale(1); }
    100%{ transform: rotate(360deg) scale(1.05); }
  }
  @keyframes levelUpRing{
    0%{ transform: scale(0.68); opacity: 0; }
    20%{ opacity: 0.9; }
    100%{ transform: scale(1.06); opacity: 0; }
  }
  @keyframes levelUpGradient{
    0%{ background-position: 0% 50%; }
    100%{ background-position: 100% 50%; }
  }
  @keyframes levelUpTextPulse{
    0%{ filter: drop-shadow(0 0 0 rgba(255,215,0,0)); transform: scale(1); }
    50%{ filter: drop-shadow(0 0 18px rgba(255,215,0,0.22)); transform: scale(1.015); }
    100%{ filter: drop-shadow(0 0 0 rgba(255,215,0,0)); transform: scale(1); }
  }


  /* Stage preview a bit larger */
  .stage{ overflow: hidden; }
  /* Stage uses original asset dimensions (set via CSS vars from loaded images) */
  .stage{
    width: var(--stageW, 420px);
    height: var(--stageH, 620px);
  }
  .stage .layer{
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  
  /* Disabled / unselectable assets */
  .asset-item.disabled{
    opacity: 0.35;
    filter: grayscale(1);
    pointer-events: auto;
  }
  .asset-item.disabled::after{
    content: "不可選";
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 800;
    letter-spacing: 1px;
    color: #fff;
    background: rgba(0,0,0,0.45);
    border-radius: 14px;
      z-index: 20;
    pointer-events: none;
}

  /* ensure upgrade button is never dimmed/covered even when card is disabled */
  .asset-item.disabled.can-upgrade{
    opacity: 1 !important;
    filter: none !important;
  }
  .asset-item.disabled.can-upgrade::after{
    display: none !important; /* hide 不可選 overlay when upgrade available */
  }



  /* Collection unlock FX */
  #collectionFx{
    position: fixed;
    inset: 0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index: 10001;
    pointer-events:none;
    background: rgba(0,0,0,0.22);
    backdrop-filter: blur(2px);
  }
  #collectionFx.active{ display:flex; }


/* ===== Unlock Overlay ===== */
#unlock-overlay{
  position:fixed;
  inset:0;
  z-index:999999;
  background:radial-gradient(circle at center, rgba(0,0,0,0.75), rgba(0,0,0,0.95));
  display:none;
  flex-direction:column;
  align-items:center;
  justify-content:space-between;
  padding:40px 20px 60px;
  overflow:hidden;
}
#unlock-overlay.unlock-open{ display:flex; }
#unlock-overlay.unlock-hidden{ display:none; }

#unlock-overlay .unlock-flash{
  position:absolute; inset:0;
  background:rgba(255,255,255,0.9);
  opacity:0;
  pointer-events:none;
}
#unlock-overlay.unlock-open .unlock-flash{
  animation:unlockFlash 0.45s ease-out 1;
}
@keyframes unlockFlash{
  0%{opacity:0;}
  15%{opacity:1;}
  100%{opacity:0;}
}

#unlock-overlay .unlock-particles{
  position:absolute; inset:-50%;
  opacity:0;
  pointer-events:none;
  background-image:
    radial-gradient(circle, rgba(255,255,255,0.8) 2px, transparent 2px),
    radial-gradient(circle, rgba(255,215,0,0.75) 2px, transparent 2px),
    radial-gradient(circle, rgba(0,229,255,0.7) 2px, transparent 2px);
  background-size:80px 80px;
}
#unlock-overlay.unlock-open .unlock-particles{
  animation:unlockParticles 1.1s ease-out 1;
}
@keyframes unlockParticles{
  0%{transform:scale(0.2); opacity:1;}
  100%{transform:scale(1.45); opacity:0;}
}

#unlock-overlay .unlock-title{
  font-size:56px;
  font-weight:900;
  letter-spacing:4px;
  text-align:center;
  background:linear-gradient(90deg,#ffdf00,#ff6a00,#ff00ff,#00e5ff,#00ff9c);
  background-size:400% 400%;
  -webkit-background-clip:text;
  color:transparent;
  text-shadow:0 0 20px rgba(255,255,255,0.8), 0 0 70px rgba(255,215,0,0.75);
  animation:unlockGradient 2s linear infinite, unlockPulse 0.9s ease-in-out infinite;
  position:relative;
  z-index:2;
}
@keyframes unlockGradient{
  0%{background-position:0% 50%;}
  100%{background-position:100% 50%;}
}
@keyframes unlockPulse{
  0%{transform:scale(0.95);}
  50%{transform:scale(1.05);}
  100%{transform:scale(0.95);}
}

#unlock-overlay .unlock-image-wrap{
  flex:1;
  width:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
  z-index:2;
}
#unlock-overlay .unlock-image{
  max-height:70vh;
  max-width:min(70vw, 900px);
  border-radius:16px;
  box-shadow:0 0 30px rgba(255,255,255,0.55), 0 0 140px rgba(255,215,0,0.7);
  transform:scale(0.6);
  opacity:0;
}
#unlock-overlay.unlock-open .unlock-image{
  animation:unlockPop 0.6s ease-out forwards;
}
@keyframes unlockPop{
  0%{transform:scale(0.6); opacity:0;}
  100%{transform:scale(1); opacity:1;}
}

#unlock-overlay .unlock-confirm{
  padding:14px 52px;
  font-size:22px;
  font-weight:900;
  border:none;
  border-radius:32px;
  cursor:pointer;
  background:linear-gradient(90deg,#ffdf00,#ff6a00);
  color:#000;
  box-shadow:0 0 20px rgba(255,215,0,0.8), 0 0 60px rgba(255,106,0,0.75);
  transition:transform 0.12s ease;
  position:relative;
  z-index:3;
}
#unlock-overlay .unlock-confirm:hover{ transform:scale(1.05); }
#unlock-overlay .unlock-confirm:active{ transform:scale(0.98); }
/* ===== End Unlock Overlay ===== */


/* ===== Scrollbar stability fix ===== */
html{
  scrollbar-gutter: stable both-edges;
}
body{
  overflow-y: scroll;
  overflow-x: hidden;
}

/* Prevent accidental overflow caused by flex/grid */
.wrap, .page-wrap, .heroStage, .featureStage, .asset-grid, .grid{
  max-width: 100%;
  box-sizing: border-box;
}

/* Prevent layout jitter from transforms */
*{
  backface-visibility: hidden;
}


  /* ===== Production layout fix: widen + height align asset panel, hide scrollbars ===== */

  /* Row 1 height locks to stage bottom alignment */
  .studio-layout{ grid-template-rows: var(--stageH, 620px) auto !important; }

  /* masterpage always on top */
  #acfMasterMount{
    position: sticky;
    top: 0;
    z-index: 99999;
  }

  /* Right side column aligns to stage bottom, no outer scrollbar */
  .studio-right{
    height: var(--stageH, 620px) !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 10px !important;
    min-height: 0 !important;
    overflow: hidden !important;
  }

  /* Tabs: allow swipe scroll but hide scrollbar */
  .tabs-container{
    flex: 0 0 auto !important;
    overflow-x: auto !important;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  .tabs-container::-webkit-scrollbar{ height: 0; }

  /* Active picker section fills remaining height */
  .picker-section{
    flex: 1 1 auto !important;
    min-height: 0 !important;
  }

  :root{
    --thumbW: 64px;
    --thumbH: 96px;
    --thumbGap: 8px;
    --assetPad: 10px;
  }

  /* Asset grid: exact width for 7 cards, height to stage bottom, hide scrollbars */
  .asset-grid{
    width: calc(7 * var(--thumbW) + 6 * var(--thumbGap) + 2 * var(--assetPad)) !important;
    box-sizing: border-box !important;

    flex: 1 1 auto !important;
    min-height: 0 !important;
    height: 100% !important;

    padding: var(--assetPad) !important;

    overflow-y: auto !important;
    overflow-x: hidden !important;

    scrollbar-width: none;
    -ms-overflow-style: none;

    border-radius: 16px !important;
  }
  .asset-grid::-webkit-scrollbar{ width: 0; height: 0; }


  /* --- System Score (Studio) --- */
  .stageOverlay{
    position:absolute;
    left: 0;
    right: 0;
    bottom: 10px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap: 10px;
    pointer-events:none;
  }
  .stageBtns{
    display:flex;
    gap: 10px;
    pointer-events:auto;
  }
  .scoreWrap{
    pointer-events:none;
  }
  .scoreFrame{
    position:relative;
    width: 240px;
    height: 72px;
  }
  .scoreFrame img{
    width:100%;
    height:100%;
    display:block;
  }
  .scoreVal{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight: 800;
    letter-spacing: 1px;
    font-size: 26px;
    text-shadow: 0 2px 10px rgba(0,0,0,.8);
  }

  /* ===== Visual polish overrides (match recipes deep dark glass panel) ===== */
  :root{
    --ui-main-bg: url('/ui/bg/main_bg.webp');
    --ui-noise: url('/ui/bg/noise.png');
    --ui-vignette: url('/ui/bg/vignette.png');
    --ui-vignette-bg: url('/ui/bg/vignette_bg.webp');
  }

  body{
    background:
      var(--ui-vignette-bg),
      var(--ui-vignette),
      var(--ui-noise),
      var(--ui-main-bg);
    background-size:
      cover,
      cover,
      300px 300px,
      cover;
    background-position:
      center,
      center,
      center,
      center;
    background-attachment:
      fixed,
      fixed,
      fixed,
      fixed;
  }

  body::after{
    content:"";
    position:fixed;
    inset:0;
    pointer-events:none;
    background: var(--ui-vignette-bg) center/cover no-repeat;
    opacity:.55;
    mix-blend-mode: multiply;
    z-index:0;
  }

  .container{ position:relative; z-index:1; }

  .card{
    background: linear-gradient(180deg, rgba(20,24,34,.72), rgba(10,12,18,.55)) !important;
    border: 1px solid rgba(255,255,255,.10) !important;
    box-shadow:
      0 18px 50px rgba(0,0,0,.55),
      inset 0 1px 0 rgba(255,255,255,.06) !important;
    border-radius: 22px !important;
    backdrop-filter: blur(10px);
  }
  .cardBody{
    background: transparent !important;
  }

  /* Score number slightly lower inside the frame */
  .scoreVal{
    font-family: "GameFontSciFi", "GameFont", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "Noto Sans TC", sans-serif;    
    transform: translateY(10px);
  }

  /* Buttons width x2 */
  .stageBtns .smallBtn{
    min-width: 180px;
    padding: 8px 14px;
    font-size: 14px;   
  }


.gold-action-btn{
    border: 2px solid rgba(255,215,0,0.9);
    background: rgba(255,215,0,0.40);
    color: #fff;
    backdrop-filter: blur(6px);
    box-shadow: 0 0 10px rgba(255,215,0,0.25), inset 0 0 8px rgba(255,215,0,0.12);
    transition: all .18s ease;
}
.gold-action-btn:hover{
    background: rgba(255,215,0,0.46);
    box-shadow: 0 0 16px rgba(255,215,0,0.45), inset 0 0 10px rgba(255,215,0,0.20);
}

</style>
</head>
<body>
<div class="acf-page ui-panel"><div id="acfMasterMount"></div>
<div class="container">
<div class="card">
<div class="cardBody">
<div class="grid">
<div class="col7">
<div class="stage">
<img alt="background" class="layer" id="bgLayer"/>
<img alt="add on 2" class="layer" id="addon2Layer"/>
<img alt="head" class="layer" id="headLayer"/>
<img alt="body" class="layer" id="bodyLayer"/>
<img alt="add on 1" class="layer" id="addon1Layer"/>
<div class="body-missing-mask" id="bodyMissingMask"></div>
<div class="stageOverlay">
<div class="scoreWrap" id="scoreWrap" title="系統評分">
<div class="scoreFrame">
<img alt="score frame" src="/ui/frame/card_scoring.webp"/>
<div class="scoreVal" id="systemScoreVal">0</div>
</div>
</div>
<div class="stageBtns">
<button class="smallBtn" data-i18n="studio_random" id="randomBtn">隨機搭配</button>
<button class="smallBtn" data-i18n="studio_save" id="submitBtn">保存</button>
</div>
</div>
</div>
<div style="height:10px"></div>
<input class="input" id="titleInput" placeholder="作品標題 例如 Neon Queen"/>
<div style="height:10px"></div>
<div class="help" id="unlockHint"></div>
</div>
<div class="col5">
<div class="tabs-container" id="assetTabs">
<button class="tab-btn active" data-i18n="studio_head" data-target="headGrid">頭部</button>
<button class="tab-btn" data-i18n="studio_body" data-target="bodyGrid">身體</button>
<button class="tab-btn" data-i18n="studio_bg" data-target="bgGrid">背景</button>
<button class="tab-btn" data-target="addon1Grid">Addon 1</button>
<button class="tab-btn" data-target="addon2Grid">Addon 2</button>
</div>
<div class="grid">
<div class="col12">
<div class="picker-section active" id="headSection"><div class="asset-grid" id="headGrid"><div class="asset-spacer"></div></div></div>
</div>
<div class="col12">
<div class="picker-section" id="bodySection"><div class="asset-grid" id="bodyGrid"><div class="asset-spacer"></div></div></div>
</div>
<div class="col12">
<div class="picker-section" id="bgSection"><div class="asset-grid" id="bgGrid"><div class="asset-spacer"></div></div></div>
</div>
<div class="col12">
<div class="picker-section" id="addon1Section"><div class="asset-grid" id="addon1Grid"><div class="asset-spacer"></div></div></div>
<div class="picker-section" id="addon2Section"><div class="asset-grid" id="addon2Grid"><div class="asset-spacer"></div></div></div>
</div>
</div>
<div class="hr"></div>
<a class="btn" data-i18n="studio_to_gallery" href="recipes.html">去看成品庫</a>
</div>
</div>
</div>
</div>
</div>
<script src="app.js"></script>
<script>
  function q(sel){ return document.querySelector(sel); }
(async function(){
    await initSession();
    // --- Tab Logic ---
    const tabBtns = document.querySelectorAll('.tab-btn');
    const sections = document.querySelectorAll('.picker-section');
    
    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = btn.getAttribute('data-target');
        const targetSectionId = targetId.replace('Grid', 'Section');
        
        tabBtns.forEach(b => b.classList.remove('active'));
        sections.forEach(s => s.classList.remove('active'));
        
        btn.classList.add('active');
        document.getElementById(targetSectionId).classList.add('active');
        
        // Trigger rerender for virtual grid when tab switches
        const gridKey = targetId.replace('Grid', '');
        if(grids[gridKey]) grids[gridKey].rerender();
      });
    });

function toThumbUrl(url){
  if(!url) return "";
  if(url.includes("_thumb.")) return url;
  const parts = String(url).split("?");
  const base = parts[0];
  const qs = parts.length > 1 ? "?" + parts.slice(1).join("?") : "";
  const m = base.match(/^(.*)\.(png|webp|jpg|jpeg)$/i);
  if(!m) return url;
  return m[1] + "_thumb." + m[2] + qs;
}
function bestThumb(url){
  const t = toThumbUrl(url);
  return t || url || "";
}


const TRANSPARENT_GIF = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";



window.showLevelUpFx = function showLevelUpFx(payload){
  const fx = q("#levelUpFx");
  if(!fx) return;

  const rangeEl = q("#levelUpRange");
  const cardEl = fx.querySelector(".levelUpCard");

  if(cardEl) cardEl.textContent = "NEW COMBINATION UNLOCKED!";

  const RARITY_LABEL = {1:"C",2:"R",3:"SR",4:"SSR",5:"UR"};

  let fromLabel = "";
  let toLabel = "";

  if(payload && typeof payload === "object"){
    fromLabel = String(payload.from || payload.oldMaxLabel || payload.oldMax || payload.x || "");
    toLabel = String(payload.to || payload.newMaxLabel || payload.newMax || payload.y || "");
    const baseRarity = Number(payload.baseRarity || payload.base || 0);
    const oldStars = Number(payload.oldStars || payload.beforeStars || 0);
    const newStars = Number(payload.newStars || payload.afterStars || 0);

    if((!fromLabel || !toLabel) && baseRarity && oldStars && newStars){
      const clampStars = (n)=>{
        let s = Number(n || 0);
        if(!Number.isFinite(s) || s < 1) s = 1;
        if(s > 5) s = 5;
        return s;
      };
      const oldMax = Math.min(5, baseRarity + (clampStars(oldStars) - 1));
      const newMax = Math.min(5, baseRarity + (clampStars(newStars) - 1));
      fromLabel = RARITY_LABEL[oldMax] || "";
      toLabel = RARITY_LABEL[newMax] || "";
    }
  }

  if(rangeEl){
    if(fromLabel && toLabel){
      const safe = (s)=>String(s||"").replace(/[^A-Z]/g,"");
      const f = safe(fromLabel);
      const t = safe(toLabel);
      rangeEl.innerHTML =
        `<span class="rarity rar-${f}">${f}</span>` +
        `<span class="rar-arrow"> =&gt; </span>` +
        `<span class="rarity rar-${t}">${t}</span>`;
    }else{
      rangeEl.textContent = "";
    }
  }

  fx.classList.add("active");
};





function normId(v){
  if(v === null || v === undefined) return "";
  return String(v).trim();
}

function normAddonPair(a1, a2){
  const ids = [normId(a1), normId(a2)].filter(Boolean);
  ids.sort();
  return ids;
}

async function ensureRecipesLoaded(){
  if(db.recipes && db.recipes.length) return true;
  try{
    const res = await api("/api/recipes");
    if(res && Array.isArray(res.recipes)){
      db.recipes = res.recipes;
      return true;
    }
  }catch(e){}
  return !!(db.recipes && db.recipes.length);
}

function recipeMatchesPayloadRow(recipe, payload){
  if(!recipe) return false;
  if(normId(recipe.headId) !== normId(payload.headId)) return false;
  if(normId(recipe.bodyId) !== normId(payload.bodyId)) return false;
  if(normId(recipe.bgId) !== normId(payload.bgId)) return false;

  const ra = normAddonPair(recipe.addon1Id, recipe.addon2Id);
  const pa = normAddonPair(payload.addon1Id, payload.addon2Id);

  if(ra.length !== pa.length) return false;
  for(let i=0;i<ra.length;i++){
    if(ra[i] !== pa[i]) return false;
  }
  return true;
}

function findMatchingRecipeIdsFromRows(payload){
  const rs = (db.recipes || []);
  const ids = [];
  for(const r of rs){
    if(recipeMatchesPayloadRow(r, payload)) ids.push(r.recipeId);
  }
  return ids;
}

async function unlockRecipeOnline(recipeId){
  try{
    const res = await api("/api/unlock", {
      method:"POST",
      body: JSON.stringify({ recipeId })
    });
    return res;
  }catch(e){
    return null;
  }
}

function unlockRecipeOffline(recipeId){
  const db2 = offlineDb();
  db2.unlocks = db2.unlocks || {};
  db2.unlocks[`${APP.uid}:${recipeId}`] = Date.now();
  saveOfflineDb(db2);
  // keep in-memory db in sync too
  db.unlocks = db.unlocks || {};
  db.unlocks[`${APP.uid}:${recipeId}`] = db2.unlocks[`${APP.uid}:${recipeId}`];
}



function setImgWithFallback(imgEl, primaryUrl, fallbackUrl) {
  if(!imgEl) return;
  const primary = String(primaryUrl || "");
  const fallback = String(fallbackUrl || "");
  imgEl.dataset._fallback = fallback;
  imgEl.dataset._triedFallback = "0";
  imgEl.onload = () => {
    try{
      const st = q(".stage");
      if(st && imgEl.naturalWidth && imgEl.naturalHeight){
        st.style.setProperty("--stageW", imgEl.naturalWidth + "px");
        st.style.setProperty("--stageH", imgEl.naturalHeight + "px");
      }
    }catch(e){}
  };
  imgEl.onerror = () => {
    // Try fallback once (thumb -> original), then hide/clear
    if(imgEl.dataset._triedFallback !== "1" && imgEl.dataset._fallback) {
      imgEl.dataset._triedFallback = "1";
      imgEl.src = imgEl.dataset._fallback;
      return;
    }
    imgEl.onerror = null;
    imgEl.src = TRANSPARENT_GIF;
  };
  imgEl.src = primary || fallback || TRANSPARENT_GIF;
}
function listImgUrl(it){
  const id = (it && it.assetId) ? String(it.assetId) : "";
  const url = (it && it.imageUrl) ? String(it.imageUrl) : "";
  if(id.startsWith("head_") || id.startsWith("body_")) return toThumbUrl(url) || url;
  return url;
}

function genderTag(assetId){
  const id = String(assetId || "").toLowerCase();
  if(id.includes("f")) return "f";
  if(id.includes("m")) return "m";
  return "";
}

function isGenderCompatible(headId, bodyId){
  const headGender = genderTag(headId);
  const bodyGender = genderTag(bodyId);
  if(!headGender || !bodyGender) return true;
  return headGender === bodyGender;
}

// --- Star & Count Logic ---
function getAssetStats(assetId, count, starsFromDb) {
  let stars = Number(starsFromDb || 0);
  if(!Number.isFinite(stars) || stars < 1) stars = 1;
  if(stars > 5) stars = 5;

  const neededForNext = (stars >= 5) ? "MAX" : (stars * 10);
  return { stars, neededForNext, totalCount: Number(count || 0) };
}

// --- System Scoring ---
const BASE_SCORE = { 1:500, 2:700, 3:1000, 4:1500, 5:2500 };
function normTags(tagStr){
  return String(tagStr || "")
    .split(",")
    .map(t => t.trim().toLowerCase())
    .filter(Boolean);
}
function tagBonusPct(n){
  if(n >= 5) return 0.80;
  if(n === 4) return 0.40;
  if(n === 3) return 0.20;
  if(n === 2) return 0.10;
  return 0.0;
}
function calcAssetScore(assetId){
  const id = String(assetId || "");
  if(!id) return { score:0, tags:[] };
  const a = (db.assets || []).find(x => String(x.assetId) === id) || null;
  const rarity = Number(a?.rarity || 1);
  const base = Number(BASE_SCORE[rarity] || 0);

  const ua = (db.userAssets || db.playerAssets || db.assetsOwned || {})[id] || {};
  let stars = Number(ua.stars || 1);
  if(!Number.isFinite(stars) || stars < 1) stars = 1;
  if(stars > 5) stars = 5;

    const tags = normTags(a?.tags);
  const theme = String(db.seasonThemeTag || "").trim().toLowerCase();

  const starBonus = (stars > 1) ? (0.2 * (stars - 1)) : 0;
  const themeBonus = (theme && tags.includes(theme)) ? 0.3 : 0;

  const score = base * (1 + starBonus + themeBonus);

  return { score, tags };
}
function computeSystemScore(payload){
  const ids = [payload.headId, payload.bodyId, payload.bgId, payload.addon1Id, payload.addon2Id].map(normId).filter(Boolean);
  const per = ids.map(calcAssetScore).map(x => ({ ...x, score: Math.round(Number(x.score)||0) }));
  const sumBase = per.reduce((acc, x) => acc + (Number(x.score)||0), 0);

  // Tag synergy bonus: sum each tag's bonus by its appearance count across different assets.
  const counts = {};
  per.forEach(x => (x.tags || []).forEach(t => { counts[t] = (counts[t]||0)+1; }));
  let bonus = 0;
  Object.keys(counts).forEach(t => { bonus += tagBonusPct(counts[t]); });

  const total = Math.round(sumBase * (1 + bonus));
  return { total, sumBase: Math.round(sumBase), bonusPct: bonus };
}

function animateNumber(el, from, to, durationMs){
  const start = performance.now();
  const dur = Math.max(120, Math.min(600, Number(durationMs||220)));
  const a = Number(from||0);
  const b = Number(to||0);
  if(window.__scoreAnimRaf) cancelAnimationFrame(window.__scoreAnimRaf);
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function tick(now){
    const p = Math.min(1, (now - start) / dur);
    const v = a + (b - a) * easeOutCubic(p);
    el.textContent = String(Math.round(v));
    if(p < 1) window.__scoreAnimRaf = requestAnimationFrame(tick);
    else { el.textContent = String(Math.round(b)); window.__scoreAnimRaf = 0; }
  }
  window.__scoreAnimRaf = requestAnimationFrame(tick);
}

function renderSystemScore(){
  const el = q("#systemScoreVal");
  if(!el) return;

  const anySelected = !!(SEL.headId || SEL.bodyId || SEL.bgId || SEL.addon1Id || SEL.addon2Id);

  const current = Number(window.__systemScore || 0);
  if(!anySelected){
    window.__systemScore = 0;
    animateNumber(el, current, 0, 220);
    return;
  }

  const payload = { headId: SEL.headId || "", bodyId: SEL.bodyId || "", bgId: SEL.bgId || "", addon1Id: SEL.addon1Id || "", addon2Id: SEL.addon2Id || "" };
  const r = computeSystemScore(payload);
  const next = Number(r.total || 0);

  window.__systemScore = next;
  animateNumber(el, current, next, 220);
}



    let db = offlineDb();

if(!APP.offline){
  try{
    const assetsRes = await fetch(WORKER_BASE + "/api/assets").then(r=>r.json());
    const rawAssets = assetsRes.assets || assetsRes.items || assetsRes.rows || assetsRes.results || [];
    const assets = (rawAssets || []).map(a=>{
      const t = String(a.type || "");
      let type = t;
      if(t === "bg") type = "background";
      if(t === "addon1" || t === "addon2") type = "accessory";
      if(t === "backgrounds") type = "background";
      return { assetId: a.assetId, type, rarity: Number(a.rarity||1), imageUrl: a.imageUrl, tags: a.tags || "" };
    });

    // Current season theme (for scoring)
    try{
      const sres = await fetch(WORKER_BASE + "/api/season/current").then(r=>r.json());
      db.seasonThemeTag = String(sres.themeTag || sres.theme || "").trim().toLowerCase();
    }catch(e){
      db.seasonThemeTag = "";
    }


    const invRes = await fetch(WORKER_BASE + "/api/me/assets?uid=" + encodeURIComponent(APP.uid)).then(r=>r.json());
    const items = invRes.items || invRes.assets || invRes.rows || invRes.results || [];
    const storeCount = {};
    const storeStars = {};
    for(const it of (items || [])){
      const aid = it.assetId || it.asset_id || it.id;
      if(!aid) continue;
      storeCount[`${APP.uid}:${aid}`] = Number(it.count || it.qty || 1);
      const s = it.stars;
      if(s !== undefined && s !== null && s !== "") storeStars[`${APP.uid}:${aid}`] = Number(s);
    }

    db = { assets, userAssets: storeCount, userStars: storeStars, unlocks: {} };
  }catch(e){
    db = offlineDb();
  }
}

    const byId = new Map(db.assets.map(a=>[a.assetId,a]));

    // refresh counts/stars from DB after upgrade
    window.reloadInventory = async function reloadInventory(){
      if(APP.offline) return;
      const invRes = await fetch(WORKER_BASE + "/api/me/assets?uid=" + encodeURIComponent(APP.uid)).then(r=>r.json());
      const items = invRes.items || invRes.assets || invRes.rows || invRes.results || [];
      const storeCount = {};
      const storeStars = {};
      for(const it of (items || [])){
        const aid = it.assetId || it.asset_id || it.id;
        if(!aid) continue;
        storeCount[`${APP.uid}:${aid}`] = Number(it.count || it.qty || 0);
        const s = it.stars;
        if(s !== undefined && s !== null && s !== "") storeStars[`${APP.uid}:${aid}`] = Number(s);
      }
      db.userAssets = storeCount;
      db.userStars = storeStars;
      enforceRarityAfterHeadChange();
      Object.values(grids).forEach(g=>g && g.rerender && g.rerender());
    };

    async function saveOnline(payload){
      try{
        const res = await api("/api/save", {
          method: "POST",
          body: JSON.stringify(payload)
        });
        if(res && res.ok) return res;
        return res || null;
      }catch(e){
        return null;
      }
    }

    async function saveOffline(payload){
      const db2 = offlineDb();
      const id = crypto.randomUUID();
      const savedOn = Date.now();
      const row = {
        id,
        userId: APP.uid,
        headId: payload.headId,
        bodyId: payload.bodyId,
        bgId: payload.bgId,
        addon1Id: payload.addon1Id || "",
        addon2Id: payload.addon2Id || "",
        savedOn
      };
      db2.saves = db2.saves || [];
      db2.saves.unshift(row);
      saveOfflineDb(db2);
      return { ok:true, id, savedOn };
    }

    function showUnlock(ids){
      const el = q("#unlockHint");
      if(!el) return;
      el.textContent = (!ids || ids.length === 0) ? "沒有觸發成品解鎖" : `已解鎖成品 ${ids.join("  ")}`;
    }

    function invCount(assetId){
      const k = `${APP.uid}:${assetId}`;
      const store = db.userAssets || db.playerAssets || db.assetsOwned || {};
      return Number(store[k] || store[assetId] || 0);
    }

    function ownedOptions(type){
      const list = db.assets.filter(a=>a.type===type && invCount(a.assetId) > 0);
      list.sort(byRarityDesc);
      return list;
    }

const SEL = { headId: "", bodyId: "", bgId: "", addon1Id: "", addon2Id: "" };

const unlockedAssetIds = new Set();
for(const key of Object.keys(db.unlocks || {})){
  if(!key.startsWith(APP.uid + ":")) continue;
  const recipeId = key.split(":")[1];
  const r = (db.recipes || []).find(x=>x.recipeId === recipeId);
  if(!r) continue;
  [r.headId, r.bodyId, r.bgId, ...(r.accessoryIds||[])].filter(Boolean).forEach(id => unlockedAssetIds.add(id));
}

function invStars(assetId){
  return Number(db.userStars?.[`${APP.uid}:${assetId}`] ?? 0);
}

const RARITY_LABEL = {1:"C",2:"R",3:"SR",4:"SSR",5:"UR"};

function clampStars(n){
  let s = Number(n || 0);
  if(!Number.isFinite(s) || s < 1) s = 1;
  if(s > 5) s = 5;
  return s;
}

// Effective rarity = base rarity + (stars - 1), capped at 5
function effectiveRarityById(assetId){
  if(!assetId) return 0;
  const base = (typeof getBaseRarityById === 'function' ? (getBaseRarityById(assetId) || 1) : Number(byId.get(assetId)?.rarity || 1));
  const stars = clampStars(invStars(assetId));
  return Math.min(5, base + (stars - 1));
}

function getBaseRarityById(assetId){
  if(!assetId) return 0;
  const fromMap = Number(byId.get(assetId)?.rarity || 0);
  if(fromMap) return fromMap;
  const parts = String(assetId).split("_");
  const n = Number(parts[1] || 0);
  return Number.isFinite(n) && n >= 1 ? n : 0;
}

function getHeadRule(){
  if(!SEL.headId) return { base: 0, max: 0 };
  const base = Number(byId.get(SEL.headId)?.rarity || 1);
  const stars = clampStars(invStars(SEL.headId));
  const max = Math.min(5, base + (stars - 1));
  return { base, max };
}

// Compatibility rules (stars increase possibilities, not restrictions)
// 1) Same or higher base rarity allowed up to head max tier (regardless of their stars)
// 2) Lower base rarity allowed only if that item is upgraded enough to reach head base tier
function isCompatibleWithHead(candidateId){
  if(!candidateId) return true;
  const rule = getHeadRule();
  if(!rule.base) return true;

  const base = Number(byId.get(candidateId)?.rarity || 1);
  const maxEff = effectiveRarityById(candidateId);

  if(base >= rule.base && base <= rule.max) return true;
  if(base < rule.base && maxEff >= rule.base) return true;

  return false;
}

function ruleHintText(){
  const r = getHeadRule();
  if(!r.base) return "";
  return `可搭配 ${RARITY_LABEL[r.base] || "C"} 至 ${RARITY_LABEL[r.max] || "C"}（較低等級需升星補足到 ${RARITY_LABEL[r.base] || "C"}）`;
}

function setLayers(){
  const bgUrl = byId.get(SEL.bgId)?.imageUrl || "";
  const a2Url = byId.get(SEL.addon2Id)?.imageUrl || "";
  const headRawUrl = byId.get(SEL.headId)?.imageUrl || "";
  const bUrl = byId.get(SEL.bodyId)?.imageUrl || "";
  const a1Url = byId.get(SEL.addon1Id)?.imageUrl || "";

  // If only head is selected (no body yet), show head thumb preview (faster + looks better)
  const hUrl = (SEL.headId && !SEL.bodyId) ? bestThumb(headRawUrl) : headRawUrl;

  // Stage layers: if empty or failed to load, use transparent and hide the layer so no broken icon shows
  const bgEl = q("#bgLayer");
  const a2El = q("#addon2Layer");
  const hEl  = q("#headLayer");
  const bEl  = q("#bodyLayer");
  const a1El = q("#addon1Layer");

  const setStage = (el, primary, fallback) => {
    if(!el) return;
    if(!primary){
      el.src = TRANSPARENT_GIF;
      el.style.display = "none";
      el.onerror = null;
      return;
    }
    el.style.display = "block";
    el.onerror = () => {
      el.onerror = null;
      el.src = TRANSPARENT_GIF;
      el.style.display = "none";
    };
    el.src = primary || fallback || TRANSPARENT_GIF;
  };

  setStage(bgEl, bgUrl, "");
  setStage(a2El, a2Url, "");
  setStage(hEl,  hUrl,  "");
  setStage(bEl,  bUrl,  "");
  setStage(a1El, a1Url, "");

  // body missing mask:
  // When only head is selected (no body yet), do NOT show the semi-transparent cover.
  const maskEl = q("#bodyMissingMask");
  if(maskEl){
    maskEl.style.display = (!SEL.bodyId && !SEL.headId) ? "block" : "none";
  }
}


function refreshPreview(){ setLayers(); renderSystemScore(); }

const hoverBox = q("#hoverPreview");
const hoverImg = hoverBox.querySelector("img");
function showHover(src, x, y){
  const s = String(src || "");
  if(!s){ hideHover(); return; }
  hoverImg.onerror = ()=>{ hideHover(); };
  hoverImg.src = s;
  hoverBox.style.display = "block";
  moveHover(x, y);
}
function moveHover(x, y){
  const pad = 16;
  const w = hoverBox.offsetWidth || 213;
  const h = hoverBox.offsetHeight || 320;
  let left = x + pad;
  let top = y + pad;
  if(left + w > window.innerWidth - 8) left = x - w - pad;
  if(top + h > window.innerHeight - 8) top = y - h - pad;
  hoverBox.style.left = left + "px";
  hoverBox.style.top = top + "px";
}
function hideHover(){ hoverBox.style.display = "none"; hoverImg.src = ""; }

function makeVirtualGrid(container, items0, getSelectedId, onSelect, options){
  let items = items0 || [];
  const opt = Object.assign({thumbW:64, thumbH:96, gap:8}, options || {});
  const spacer = container.querySelector(".asset-spacer") || container;
  
  function calcCols(){
    return Math.max(1, Math.floor((container.clientWidth + opt.gap) / (opt.thumbW + opt.gap)));
  }

  function rerender(){
    const cols = calcCols();
    const rowH = opt.thumbH + opt.gap;
    const rows = Math.ceil(items.length / cols);
    spacer.style.height = (rows * rowH) + "px";
    spacer.style.position = "relative";
    const scrollTop = container.scrollTop;
    const viewH = container.clientHeight;
    const startRow = Math.max(0, Math.floor(scrollTop / rowH) - 2);
    const endRow = Math.min(rows, Math.ceil((scrollTop + viewH) / rowH) + 2);
    spacer.innerHTML = "";

    for(let r = startRow; r < endRow; r++){
      for(let c = 0; c < cols; c++){
        const idx = r * cols + c;
        if(idx >= items.length) break;
        const it = items[idx];
        const wrap = document.createElement("div");
        const baseR = it.assetId ? (typeof getBaseRarityById === 'function' ? (getBaseRarityById(it.assetId) || 1) : Number(byId.get(it.assetId)?.rarity || 1)) : Number(it.rarity || 1);
        wrap.className = "asset-item " + `r${baseR || 1}`;
        if(it._disabled) wrap.classList.add("disabled");
        if(it.assetId) wrap.setAttribute("data-asset-id", String(it.assetId));
        wrap.style.left = (c * (opt.thumbW + opt.gap)) + "px";
        wrap.style.top = (r * rowH) + "px";

        const img = document.createElement("img");
        img.className = "asset-thumb";
        const primarySrc = listImgUrl(it) || "";
const fallbackSrc = (it && it.imageUrl) ? String(it.imageUrl) : "";
if(!primarySrc && !fallbackSrc){
  img.src = TRANSPARENT_GIF;
}else{
  img.src = primarySrc || fallbackSrc || TRANSPARENT_GIF;
}
img.dataset._fallbackThumb = fallbackSrc;
img.dataset._triedFallbackThumb = "0";
img.addEventListener("error", ()=>{
  // head/body: if thumb missing, fallback to original; otherwise use transparent
  if(img.dataset._triedFallbackThumb !== "1" && fallbackSrc && (String(it.assetId||"").startsWith("head_") || String(it.assetId||"").startsWith("body_"))){
    img.dataset._triedFallbackThumb = "1";
    img.src = fallbackSrc;
    return;
  }
  img.src = TRANSPARENT_GIF;
});
        if(getSelectedId() === it.assetId) img.classList.add("active");

        img.addEventListener("click", ()=>{ if(it._disabled) return; onSelect(it.assetId); rerender(); });
        img.addEventListener("mouseenter", (e)=>{
          const hs = (listImgUrl(it) || (it && it.imageUrl) || "");
          if(!hs) return;
          showHover(hs, e.clientX, e.clientY);
        });
        img.addEventListener("mousemove", (e)=>moveHover(e.clientX, e.clientY));
        img.addEventListener("mouseleave", hideHover);
        wrap.appendChild(img);

        // --- Stats Badges ---
        if(it.assetId) {
          const count = invCount(it.assetId);
          const stats = getAssetStats(it.assetId, count, invStars(it.assetId));
          const neededNum = (stats.stars >= 5) ? null : (stats.stars * 10);
          const canUpgrade = !!neededNum && stats.totalCount >= neededNum;
          if(canUpgrade) wrap.classList.add('can-upgrade');
          
          // Count Badge (Top Right)
          const cBadge = document.createElement("div");
          cBadge.className = "badge-count";
          cBadge.textContent = `${stats.totalCount}/${stats.neededForNext}`;
          if(stats.stars >= 5) cBadge.classList.add("gray");
          else if(canUpgrade) cBadge.classList.add("ready");
          else cBadge.classList.add("notready");
          wrap.appendChild(cBadge);

          // Rarity Badge (Top Left) show only when not using thumb image
          const imgSrc = String(it.imageUrl || "");
          if(imgSrc && !imgSrc.includes("_thumb")){
            const rBadge = document.createElement("div");
            rBadge.className = "badge-rarity";
            const rMap = {1:"C",2:"R",3:"SR",4:"SSR",5:"UR"};
            const r = it.assetId ? (typeof getBaseRarityById === 'function' ? (getBaseRarityById(it.assetId) || 1) : Number(byId.get(it.assetId)?.rarity || 1)) : Number(it.rarity || 1);
            rBadge.textContent = rMap[r] || "C";
            wrap.appendChild(rBadge);
          }
          
          // Star Badge (Bottom Left)
          const sBadge = document.createElement("div");
          sBadge.className = "badge-stars";
          sBadge.textContent = "★".repeat(stats.stars);
          
          wrap.appendChild(sBadge);

          // Upgrade overlay
          if(canUpgrade){
            const ov = document.createElement("div");
            ov.className = "upgrade-overlay";
            const label = document.createElement("span");
            label.textContent = "可升級";
            ov.appendChild(label);
            ov.addEventListener("click", async (e)=>{
              e.preventDefault();
              e.stopPropagation();
              await doUpgrade(it.assetId);
              rerender();
            });
            wrap.appendChild(ov);
          }
        }

        if(unlockedAssetIds.has(it.assetId)){
          const b = document.createElement("div");
          b.className = "badge-unlocked";
          b.textContent = "✓";
          wrap.appendChild(b);
        }
        spacer.appendChild(wrap);
      }
    }
  }
  container.addEventListener("scroll", rerender);
  window.addEventListener("resize", rerender);
  rerender();
  return { rerender, setItems: (next)=>{ items = Array.isArray(next) ? next : []; container.scrollTop = 0; rerender(); } };
}

const grids = {};
const headItemsAll = ownedOptions("head");
let headItems = headItemsAll;
const bodyItemsAll = ownedOptions("body");
let bodyItems = bodyItemsAll;
const bgItemsAll = ownedOptions("background");
let bgItems = bgItemsAll;

SEL.headId = headItems[0]?.assetId || "";
SEL.bodyId = bodyItems[0]?.assetId || "";

function applyBodyGenderRule(){
  const headGender = genderTag(SEL.headId);
  // if current body is opposite gender, clear it instead of keeping an invalid selection
  if(headGender && SEL.bodyId){
    const bg = genderTag(SEL.bodyId);
    if(bg && bg !== headGender) SEL.bodyId = "";
  }
  let filtered = bodyItemsAll;

  if(headGender){
    filtered = filtered.filter(it => {
      const bodyGender = genderTag(it.assetId);
      return !bodyGender || bodyGender === headGender;
    });
  }

  filtered = filtered.map(it => ({...it, _disabled: !isCompatibleWithHead(it.assetId)}));
bodyItems = filtered.length > 0 ? filtered : bodyItemsAll;

  // keep selection valid
  if(SEL.bodyId && !bodyItems.some(it=>it.assetId === SEL.bodyId)){
    SEL.bodyId = "";
  }
  if(grids.body) grids.body.setItems(bodyItems);
}

function applyBgRarityRule(){
  const filtered = bgItemsAll.map(it => ({...it, _disabled: !isCompatibleWithHead(it.assetId)}));
  bgItems = filtered.length ? filtered : bgItemsAll;
  if(SEL.bgId && !bgItems.some(it=>it.assetId === SEL.bgId)){
    SEL.bgId = bgItems[0]?.assetId || "";
  }
  if(grids.bg) grids.bg.setItems(bgItems);
}

function applyAddonRarityRule(){
  const filterOne = (pool) => pool.map(it => ({...it, _disabled: !!it.assetId && !isCompatibleWithHead(it.assetId)}));

  addon1Pool = filterOne(addon1PoolAll);
  addon2Pool = filterOne(addon2PoolAll);

  if(SEL.addon1Id && !addon1Pool.some(it=>it.assetId === SEL.addon1Id)) SEL.addon1Id = "";
  if(SEL.addon2Id && !addon2Pool.some(it=>it.assetId === SEL.addon2Id)) SEL.addon2Id = "";

  if(grids.addon1) grids.addon1.setItems([noneItem, ...addon1Pool]);
  if(grids.addon2) grids.addon2.setItems([noneItem, ...addon2Pool]);
}

function enforceRarityAfterHeadChange(){
  const r = getHeadRule();
  if(!r.base) return;

  // reset incompatible selections
  if(SEL.bodyId && !isCompatibleWithHead(SEL.bodyId)) SEL.bodyId = "";
  if(SEL.bgId && !isCompatibleWithHead(SEL.bgId)) SEL.bgId = "";
  if(SEL.addon1Id && !isCompatibleWithHead(SEL.addon1Id)) SEL.addon1Id = "";
  if(SEL.addon2Id && !isCompatibleWithHead(SEL.addon2Id)) SEL.addon2Id = "";


  // gender compatibility: if head has gender, clear any selected items with opposite gender
  const hg = genderTag(SEL.headId);
  if(hg){
    const clearIfMismatch = (key)=>{
      const id = SEL[key];
      if(!id) return;
      const g = genderTag(id);
      if(g && g !== hg) SEL[key] = "";
    };
    clearIfMismatch("bodyId");
    clearIfMismatch("addon1Id");
    clearIfMismatch("addon2Id");
  }
  applyBodyGenderRule();
  applyBgRarityRule();
  applyAddonRarityRule();
}

function canSelectSameRarity(newAssetId){
  if(!newAssetId) return true;
  if(!isCompatibleWithHead(newAssetId)){
    toast(ruleHintText() || "素材不匹配");
    return false;
  }
  return true;
}
applyBodyGenderRule();

const addonAll = ownedOptions("accessory");
const byPrefix = (prefix) => addonAll.filter(a=>((a.imageUrl || "").split("/").pop() || "").startsWith(prefix));
let addon1Pool = byPrefix("addon1_");
let addon2Pool = byPrefix("addon2_");
if(addon1Pool.length === 0 && addon2Pool.length === 0){ addon1Pool = addonAll; addon2Pool = addonAll; }
else { if(addon1Pool.length === 0) addon1Pool = addonAll; if(addon2Pool.length === 0) addon2Pool = addonAll; }

const addon1PoolAll = addon1Pool.slice();
const addon2PoolAll = addon2Pool.slice();

const noneItem = { assetId:"", imageUrl:"", rarity:1 };

grids.head = makeVirtualGrid(q("#headGrid"), headItemsAll, ()=>SEL.headId, (id)=>{ SEL.headId=id; enforceRarityAfterHeadChange(); refreshPreview(); Object.values(grids).forEach(g=>g && g.rerender && g.rerender()); });
grids.body = makeVirtualGrid(q("#bodyGrid"), bodyItems, ()=>SEL.bodyId, (id)=>{ if(!canSelectSameRarity(id)) return; SEL.bodyId=id; refreshPreview(); });
grids.bg = makeVirtualGrid(q("#bgGrid"), bgItems, ()=>SEL.bgId, (id)=>{ if(!canSelectSameRarity(id)) return; SEL.bgId=id; refreshPreview(); });
grids.addon1 = makeVirtualGrid(q("#addon1Grid"), [noneItem, ...addon1Pool], ()=>SEL.addon1Id, (id)=>{ if(id && !canSelectSameRarity(id)) return; SEL.addon1Id=id; refreshPreview(); });
grids.addon2 = makeVirtualGrid(q("#addon2Grid"), [noneItem, ...addon2Pool], ()=>SEL.addon2Id, (id)=>{ if(id && !canSelectSameRarity(id)) return; SEL.addon2Id=id; refreshPreview(); });

enforceRarityAfterHeadChange();
refreshPreview();

q("#randomBtn").addEventListener("click", ()=>{
  const hAll = ownedOptions("head");
  const bAll = ownedOptions("body");
  const gAll = ownedOptions("background");
  if(hAll.length === 0 || bAll.length === 0 || gAll.length === 0) return toast("素材不足");

  // try a few times to find a compatible full set
  let picked = false;
  for(let tries=0; tries<25 && !picked; tries++){
    const h = randPick(hAll);
    const headBase = Number(byId.get(h.assetId)?.rarity || 1);
    const headStars = clampStars(invStars(h.assetId));
    const headMax = Math.min(5, headBase + (headStars - 1));
    const hGender = genderTag(h.assetId);

    const bCandidates = bAll.filter(it=>{
      if(hGender){
        const bg = genderTag(it.assetId);
        if(bg && bg !== hGender) return false;
      }
      const base = Number(byId.get(it.assetId)?.rarity || 1);
      const maxEff = effectiveRarityById(it.assetId);
      if(base >= headBase && base <= headMax) return true;
      if(base < headBase && maxEff >= headBase) return true;
      return false;
    });

    const gCandidates = gAll.filter(it=>{
      const base = Number(byId.get(it.assetId)?.rarity || 1);
      const maxEff = effectiveRarityById(it.assetId);
      if(base >= headBase && base <= headMax) return true;
      if(base < headBase && maxEff >= headBase) return true;
      return false;
    });

    if(bCandidates.length === 0 || gCandidates.length === 0) continue;

    SEL.headId = h.assetId;
    SEL.bodyId = randPick(bCandidates).assetId;
    SEL.bgId = randPick(gCandidates).assetId;

    // accessories: optional, must match target if selected
    const aAll = ownedOptions("accessory");
    const isOk = (id)=>{
      const base = Number(byId.get(id)?.rarity || 1);
      const maxEff = effectiveRarityById(id);
      if(base >= headBase && base <= headMax) return true;
      if(base < headBase && maxEff >= headBase) return true;
      return false;
    };
    const p1 = aAll.filter(a=> (a.imageUrl||"").split("/").pop().startsWith("addon1_") && isOk(a.assetId));
    const p2 = aAll.filter(a=> (a.imageUrl||"").split("/").pop().startsWith("addon2_") && isOk(a.assetId));
    SEL.addon1Id = (p1.length ? randPick([ {assetId:""}, ...p1 ]).assetId : "");
    SEL.addon2Id = (p2.length ? randPick([ {assetId:""}, ...p2 ]).assetId : "");

    picked = true;
  }

  if(!picked) return toast("找不到可搭配的同稀有度組合");

  enforceRarityAfterHeadChange();
  refreshPreview();
  Object.values(grids).forEach(g => g && g.rerender && g.rerender());
  toast("已隨機搭配");
});

q("#submitBtn").addEventListener("click", async ()=>{
  const payload = { headId: SEL.headId, bodyId: SEL.bodyId, bgId: SEL.bgId, addon1Id: SEL.addon1Id || "", addon2Id: SEL.addon2Id || "", systemScore: Number(window.__systemScore || 0) };
  if(!payload.headId || !payload.bodyId || !payload.bgId) return toast("素材不足");
  if(!isGenderCompatible(payload.headId, payload.bodyId)) return toast("性別不匹配");
  const others = [payload.bodyId, payload.bgId, payload.addon1Id, payload.addon2Id].filter(Boolean);
  if(others.some(id => !isCompatibleWithHead(id))) return toast(ruleHintText() || "素材不匹配");
  toast("保存中");
  let data = await saveOnline(payload) || await saveOffline(payload);
  if(data && data.ok){
    if(data.alreadySaved){
      toast("該圖片已經保存在你的成品庫中了");
    }else{
      toast("已保存");
    }


    // server may return unlocked recipeIds (write-through to local + offline db and play FX)
    const unlocked = Array.isArray(data.unlocked) ? data.unlocked : [];
    if(unlocked.length){
      db.unlocks = db.unlocks || {};
      const db2 = offlineDb();
      db2.unlocks = db2.unlocks || {};
      const newlyUnlocked = [];
      for(const rid of unlocked){
        const key = `${APP.uid}:${rid}`;
        if(db.unlocks[key] || db2.unlocks[key]) continue;
        const ts = Date.now();
        db.unlocks[key] = ts;
        db2.unlocks[key] = ts;
        newlyUnlocked.push(rid);
      }
      saveOfflineDb(db2);
      if(window.showCollectionFx) window.showCollectionFx(unlocked);
    }
}else{
    toast("保存失敗");
    console.log("save_failed", data);
  }
});
refreshPreview();
})();


async function doUpgrade(assetId){
  const uid = localStorage.getItem("acf_uid");
  const card = document.querySelector(`[data-asset-id='${assetId}']`);
  if(card) card.classList.add("upgrading");

  const res = await fetch(WORKER_BASE + "/api/upgrade", {
    method:"POST",
    headers:{ "content-type":"application/json", "x-user-id": uid },
    body: JSON.stringify({ uid, assetId })
  }).then(r=>r.json());

  if(res.ok){
    const baseRarity = Number(res.baseRarity || res.base || 0);
    const oldStars = Number(res.oldStars || res.beforeStars || 0);
    const newStars = Number(res.newStars || res.afterStars || 0);

    const fromLabel = String(res.from || res.oldMaxLabel || res.oldMax || "");
    const toLabel = String(res.to || res.newMaxLabel || res.newMax || "");

    if(window.showLevelUpFx){
      window.showLevelUpFx({
        from: fromLabel,
        to: toLabel,
        baseRarity,
        oldStars,
        newStars
      });
    }

    await reloadInventory();
  }
  else{
    alert(res.error || "upgrade failed");
  }

  if(card) card.classList.remove("upgrading");
}
</script>
<div id="hoverPreview"><img alt="preview"/></div>
<div id="levelUpFx">
<div class="levelUpCardWrap">
<div class="levelUpCard">NEW COMBINATION UNLOCKED!</div>
<div class="levelUpSub" id="levelUpRange"></div>
<button class="unlock-confirm" id="levelUpConfirm" type="button">CONFIRM</button>
</div>
</div>
<div id="collectionFx">
<div>
<div class="levelUpCard">NEW COLLECTION UNLOCKED!</div>
<div class="levelUpSub" id="collectionFxSub"></div>
</div>
</div>
<!-- Unlock Overlay (Recipes) -->
<div aria-hidden="true" class="unlock-hidden" id="unlock-overlay">
<div class="unlock-flash"></div>
<div class="unlock-particles"></div>
<div class="unlock-title">NEW COLLECTION UNLOCKED!</div>
<div class="unlock-image-wrap">
<img alt="Unlocked Collection" class="unlock-image" id="unlock-img"/>
</div>
<button class="unlock-confirm" id="unlock-confirm" type="button">CONFIRM</button>
</div>
<script>
// ===== Unlock Overlay wiring =====
(function(){
  function closeUnlock(){
    const overlay = document.getElementById('unlock-overlay');
    if(!overlay) return;

    overlay.classList.remove('unlock-open');
    overlay.classList.add('unlock-hidden');
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden','true');

    // If multiple recipeIds were unlocked at once, continue showing them one by one
    const q = window.__unlockQueue || [];
    if(q.length && typeof window.__showNextUnlock === 'function'){
      setTimeout(()=>window.__showNextUnlock(), 120);
    }
  }

  function showCollectionFx(recipeIdOrList){
    // Accept a single recipeId string OR an array of recipeIds
    const overlay = document.getElementById('unlock-overlay');
    const img = document.getElementById('unlock-img');
    if(!overlay || !img) return;

    const ids = Array.isArray(recipeIdOrList) ? recipeIdOrList : [recipeIdOrList];
    const queue = (ids || []).map(x => String(x || "")).filter(Boolean);

    // Keep a global queue so CONFIRM can show next unlocked item
    window.__unlockQueue = queue;

    function showNext(){
      const q = window.__unlockQueue || [];
      const nextId = q.shift();
      window.__unlockQueue = q;
      if(!nextId) return;

      img.src = '/assets/' + nextId + '.png';

      overlay.classList.remove('unlock-hidden');
      overlay.classList.add('unlock-open');
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden','false');
    }

    // Expose so closeUnlock can continue
    window.__showNextUnlock = showNext;

    // Show immediately
    showNext();
  }

  window.showCollectionFx = showCollectionFx;
  window.closeUnlock = closeUnlock;

  document.addEventListener('DOMContentLoaded', () => {
    const overlay = document.getElementById('unlock-overlay');
    if(!overlay) return;

    overlay.classList.add('unlock-hidden');
    overlay.classList.remove('unlock-open');
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden','true');

    const btn = document.getElementById('unlock-confirm');
    if(btn) btn.addEventListener('click', closeUnlock);

    window.addEventListener('keydown', (e) => {
      if(e.key === 'Escape') closeUnlock();
    });

    overlay.addEventListener('click', (e) => {
      if(e.target === overlay) closeUnlock();
    });
  });
})();
</script>
<script>
(function(){
  function bind(){
    const fx = document.getElementById("levelUpFx");
    const btn = document.getElementById("levelUpConfirm");
    if(!fx || !btn) return;
    btn.addEventListener("click", ()=>{
      fx.classList.remove("active");
    });
  }
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", bind);
  }else{
    bind();
  }
})();
</script>
</div>
<script>
(function(){
  function updateMasterHeightStable(){
    const m = document.getElementById("acfMasterMount");
    if(!m) return;
    const hRaw = m.getBoundingClientRect().height;
    const h = Math.round(hRaw);
    const cur = parseInt(getComputedStyle(document.documentElement)
      .getPropertyValue("--masterH")) || 0;
    if(Math.abs(h-cur) >= 2){
      document.documentElement.style.setProperty("--masterH", h+"px");
    }
  }
  window.addEventListener("resize", updateMasterHeightStable);
  window.addEventListener("load", updateMasterHeightStable);
})();
</script>
</body>
</html>
