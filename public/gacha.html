<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gacha</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body{
      margin:0;
      min-height:100vh;
      background: radial-gradient(circle at top, #1b1f2a, #0b0d12);
      color:#fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "Noto Sans TC", sans-serif;
    }
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 56px 20px 88px;
    }
    h1{
      margin:0 0 18px;
      font-size: 28px;
      letter-spacing: 0.6px;
      opacity: 0.92;
      text-align:center;
    }

    .heroGrid{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 940px){
      .heroGrid{ grid-template-columns: 1fr; }
    }

    .featured{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      margin-bottom: 14px;
    }
    .featured .badge{
      display:flex;
      align-items:center;
      gap:10px;
      opacity:0.85;
      font-weight:800;
      letter-spacing:0.3px;
    }
    .featureStage{
  width: 100%;
  max-width: 980px;
  aspect-ratio: 16 / 9;
  border-radius: 26px;
  background: transparent;
  border: none;
  box-shadow: none;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
  position:relative;
}
    .featureStage:before{
      content:"";
      position:absolute;
      inset:-40%;
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,0.12), transparent 55%),
                  radial-gradient(circle at 70% 80%, rgba(121,215,255,0.10), transparent 55%),
                  radial-gradient(circle at 40% 70%, rgba(255,198,106,0.10), transparent 60%);
      filter: blur(10px);
      transform: rotate(15deg);
      pointer-events:none;
    }
    @keyframes floaty{
      0%{ transform: translateY(0) scale(1); }
      50%{ transform: translateY(-10px) scale(1.01); }
      100%{ transform: translateY(0) scale(1); }
    }
    .featureStage img, .featureStage video{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display:block;
  position:absolute;
  inset:0;
  z-index:0;
  pointer-events:none;
}

    

.promoTag{
  position:absolute;
  top:14px;
  right:14px;
  z-index:3;
  padding:10px 12px;
  border-radius: 14px;
  background: rgba(0,0,0,0.55);
  border: 1px solid rgba(255,255,255,0.18);
  backdrop-filter: blur(10px);
  text-align:right;
  pointer-events:none;
}
.promoBig{
  font-weight: 950;
  font-size: 18px;
  letter-spacing: 0.4px;
  text-shadow: 0 10px 30px rgba(0,0,0,0.75);
  white-space: nowrap;
}
.promoBoom{
  margin-top: 2px;
  font-weight: 1000;
  font-size: 28px;
  letter-spacing: 2px;
  text-shadow: 0 14px 38px rgba(0,0,0,0.85);
}

.gachaOverlay{
  position:absolute;
  left:14px;
  right:14px;
  bottom:14px;
  z-index:4;
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  align-items: stretch;
}
@media (max-width: 860px){
  .gachaOverlay{ grid-template-columns: 1fr; }
  .promoBig{ font-size: 16px; }
  .promoBoom{ font-size: 26px; }
}

.gachaCard{
  background: rgba(0,0,0,0.58);
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 18px;
  padding: 12px 12px 10px;
  backdrop-filter: blur(10px);
}
.gachaHead{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap: 10px;
  margin-bottom: 10px;
}
.gachaName{
  font-weight: 950;
  font-size: 16px;
  letter-spacing: 0.2px;
}
.gachaDesc{
  opacity: 0.85;
  font-weight: 800;
  font-size: 12px;
  white-space: nowrap;
}

.drawRow{
  display:flex;
  gap: 10px;
  align-items:flex-start;
  justify-content: space-between;
}
.drawCol{
  flex: 1;
  display:flex;
  flex-direction: column;
  align-items:center;
  gap: 4px;
}
.btn.small{
  padding: 9px 12px;
  border-radius: 12px;
  font-size: 14px;
  min-width: 92px;
}
.cost{
  font-size: 12px;
  opacity: 0.92;
  font-weight: 850;
  letter-spacing: 0.2px;
}
.guarantee{
  font-size: 12px;
  opacity: 0.88;
  font-weight: 850;
}
.pity{
  margin-top: 8px;
  font-size: 12px;
  opacity: 0.92;
  font-weight: 900;
  text-align:center;
}
.side{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .sideCard{
      border-radius: 18px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      padding: 12px 12px 12px;
    }
    .sideCard .title{
      font-weight: 900;
      letter-spacing: 0.3px;
      opacity: 0.95;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .miniRow{
      display:flex;
      gap: 10px;
    }

    .bottomGrid{
      margin-top: 16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 760px){
      .bottomGrid{ grid-template-columns: 1fr; }
    }
    .sectionCard{
      border-radius: 22px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 70px rgba(0,0,0,0.40);
      padding: 16px;
    }
    .sectionCard .head{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 12px;
      margin-bottom: 12px;
    }
    .sectionCard .head .name{
      font-weight: 950;
      letter-spacing: 0.4px;
      font-size: 18px;
    }
    .sectionCard .head .desc{
      opacity: 0.75;
      font-size: 13px;
      font-weight: 700;
    }
    .btnRow{
      display:flex;
      gap: 12px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-start;
    }

    .btn{
      border:0;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 15px;
      font-weight: 950;
      cursor:pointer;
      letter-spacing:0.4px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.35);
      user-select:none;
      white-space:nowrap;
    }
    .btn.orange{
      background: linear-gradient(135deg, #ffc66a, #ff9f2f);
      color:#141414;
    }
    .btn.blue{
      background: linear-gradient(135deg, #79d7ff, #4aa8ff);
      color:#0a0f18;
    }
    .btn.gray{
      background: rgba(255,255,255,0.10);
      color:#fff;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow:none;
    }
    .btn.small{
      padding: 10px 14px;
      font-size: 14px;
      box-shadow: none;
    }

    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.55);
      padding: 18px;
      z-index: 50;
    }
    .overlay.show{ display:flex; }
    .panel{
      width:min(1100px, 96vw);
      display:flex;
      flex-direction:column;
      max-height: 92vh;
      border-radius:26px;
      background: rgba(18,22,32,0.92);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 30px 120px rgba(0,0,0,0.65);
      padding: 22px 22px 18px;
      text-align:left;
      position:relative;
      overflow:hidden;
    }
    .panel h3{
      margin:0;
      font-size:22px;
      letter-spacing:0.4px;
      display:flex;
      align-items:baseline;
      gap:12px;
    }
    .sub{
      opacity:0.75;
      font-size:14px;
      font-weight:800;
    }
    
    
    .gacha-stage{
      position:relative;
      padding:18px;
      border-radius:18px;
      background: rgba(255,255,255,0.05);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
      flex: 1 1 auto;
      overflow:auto;
      min-height: 0;
    }

/* loadCover 顯示時，整個 30 張卡區域只剩輪廓 */
.gacha-stage.loading .grid32{
  filter: blur(18px) saturate(0.55) brightness(0.55);
  transform: scale(1.02);
}
.gacha-stage.loading .cell .label{
  opacity:0;
}

    .loadCover{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  gap: 14px;
  /* 深色遮蓋 + 強模糊，讓背後只剩輪廓 */
  background: rgba(0,0,0,0.86);
  backdrop-filter: blur(18px);
  z-index: 5;
}
.loadCover::before{
  content:"";
  position:absolute;
  inset:0;
  background:
    radial-gradient(circle at 50% 40%, rgba(255,255,255,0.06), transparent 55%),
    linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.70));
  pointer-events:none;
}
.loadCover .spinner, .loadCover .txt{
  position:relative;
  z-index:1;
}
    .loadCover.show{ display:flex; }
    .loadCover .txt{
      font-weight: 900;
      letter-spacing: 0.8px;
      opacity: 0.9;
    }
    .spinner{
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.18);
      border-top-color: rgba(255,255,255,0.85);
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin{ to { transform: rotate(360deg); } }
    /* 32 格固定尺寸，保持卡片比例不變 */
    :root{
      --cardH: 140px;
      --cardW: 93px; /* 約 2:3 */
      --gridGap: 10px;
    }
    @media (max-width: 940px){
      :root{ --cardH: 120px; --cardW: 80px; }
    }
    .grid32{
      position:relative;
      display:grid;
      grid-template-columns: repeat(10, var(--cardW));
      grid-auto-rows: var(--cardH);
      gap: var(--gridGap);
      justify-content:center;
      align-content:center;
      width: 100%;
    }
    .framesLayer{
      position:absolute;
      left:18px;
      right:18px;
      top:18px;
      bottom:18px;
      pointer-events:none;
    }
    .cell{
      position:relative;
      border-radius:14px;
      background: rgba(0,0,0,0.20);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
      overflow:hidden;
      transform: translateZ(0);
    }
    .thumbWrap{
      position:absolute;
      inset:0;
    }
    .cell img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      background: rgba(0,0,0,0.30);
      filter: saturate(0.95) contrast(1.05);
      opacity:0.98;
      transform: scale(1);
      transition: filter 220ms ease;
    }

    /* 讓所有圖永遠同尺寸，不因選中而放大 */
    .cell.win img{ filter: saturate(1.05) contrast(1.08) brightness(1.04); }
    .cell.win::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:14px;
      box-shadow: 0 0 0 2px rgba(255,215,0,0.95), 0 0 18px rgba(255,215,0,0.35);
      z-index: 5;
      pointer-events:none;
    }
    
    /* ===== per-card rarity glow when it stops (10-pull clarity) ===== */
    .cell.win.r1::after{ box-shadow: 0 0 0 2px rgba(148,163,184,0.85), 0 0 18px rgba(148,163,184,0.25); }
    .cell.win.r2::after{ box-shadow: 0 0 0 2px rgba(34,197,94,0.90), 0 0 22px rgba(34,197,94,0.30); }
    .cell.win.r3::after{ box-shadow: 0 0 0 2px rgba(59,130,246,0.92), 0 0 26px rgba(59,130,246,0.35); }
    .cell.win.r4::after{ box-shadow: 0 0 0 2px rgba(168,85,247,0.95), 0 0 34px rgba(168,85,247,0.42); }
    .cell.win.r5::after{ box-shadow: 0 0 0 2px rgba(245,158,11,0.98), 0 0 46px rgba(245,158,11,0.55), 0 0 90px rgba(255,255,255,0.18); }

    .cell.focus::after{
      animation: focusPulse 280ms ease-out 1;
    }
    @keyframes focusPulse{
      0%{ transform: scale(1); opacity: 0.6; }
      60%{ transform: scale(1.02); opacity: 1; }
      100%{ transform: scale(1); opacity: 1; }
    }

.cell.win.red::after{
      box-shadow: 0 0 0 2px rgba(255,80,80,0.98), 0 0 20px rgba(255,80,80,0.45);
    }

    .cell .label{
      position:absolute;
      left:8px;
      bottom:7px;
      font-size:11px;
      font-weight:800;
      letter-spacing:0.2px;
      padding:3px 7px;
      border-radius:999px;
      background: rgba(0,0,0,0.45);
      color: rgba(255,255,255,0.86);
      max-width: calc(100% - 16px);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      z-index: 6;
    }
    .framesLayer{position:absolute;left:18px;right:18px;top:18px;bottom:18px;pointer-events:none;}
    .jump-frame{
      position:absolute;
      border-radius:14px;
      box-sizing:border-box;
      width:50px;
      height:50px;
      transform: translateZ(0);
      transition: none;
    }

    .jump-frame.jump{
      animation: framePop 120ms ease-out;
    }
    @keyframes framePop{
      0%{ transform: scale(0.98); }
      60%{ transform: scale(1.02); }
      100%{ transform: scale(1); }
    }
    .jump-frame.gold{
      border:3px solid rgba(255, 215, 0, 0.95);
      box-shadow: 0 0 16px rgba(255,215,0,0.35);
    }
    .jump-frame.red{
      border:3px solid rgba(255, 70, 90, 0.98);
      box-shadow: 0 0 20px rgba(255,70,90,0.55);
      filter: brightness(1.15);
    }
    .jump-frame.fade{
      opacity:0;
      transition: opacity 180ms ease;
    }
    .cell.win{
      box-shadow: 0 0 0 2px rgba(255,255,255,0.10), 0 0 22px rgba(255,255,255,0.12);
    }
    .cell.win2{ box-shadow: 0 0 0 2px rgba(255,255,255,0.14), 0 0 26px rgba(255,255,255,0.16); }

    /* 沒有選中的圖加一層半透明遮罩，視覺上暗下去 */
    .cell.dim::before{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.35);
      pointer-events:none;
      z-index: 2;
    }
    .cell.dim img{
      filter: saturate(0.70) contrast(1.00) brightness(0.70);
    }
.belt{
      position:absolute;
      top:50%;
      left:0;
      transform: translate(0, -50%);
      display:flex;
      gap:12px;
      padding: 0 24px;
      will-change: transform;
    }
    .card{
      position:relative;
      width:124px;
      height:124px;
      border-radius:18px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    .card img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      background: rgba(0,0,0,0.10);
    }
    .marker{
      position:absolute;
      top:50%;
      left:50%;
      width:124px;
      height:124px;
      transform: translate(-50%, -50%);
      border-radius:14px;
      box-shadow:
        0 0 0 2px rgba(255,214,102,0.95),
        0 0 40px 10px rgba(255,214,102,0.35),
        inset 0 0 0 1px rgba(255,255,255,0.10);
      background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,0.18), transparent 45%),
        radial-gradient(circle at 70% 80%, rgba(255,214,102,0.18), transparent 55%);
      pointer-events:none;
    }
    .card.win{
      box-shadow:
        0 0 0 2px rgba(255,214,102,0.95),
        0 0 42px 12px rgba(255,214,102,0.40),
        inset 0 0 0 1px rgba(255,255,255,0.10);
      border-color: rgba(255,214,102,0.55);
    }
    

/* Pro UI: actionBar 內部疊放，切換用 opacity，不造成 reflow */
.actionBar{
  position: relative;
  display:flex;
  justify-content:center;
  align-items:center;
  gap: 0;
  margin-top: 14px;
  height: 52px; /* 固定高度：永不跳 */
  text-align:center;
  user-select:none;
}

.actionBar .statusText{
  position:absolute;
  left:50%;
  top:50%;
  transform: translate(-50%, -50%);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap: 4px;
  width: 100%;
  max-width: 92%;
  pointer-events:none;
  opacity: 1;
  transition: opacity 180ms ease;
}

.actionBar .confirm{
  position:absolute;
  left:50%;
  top:50%;
  transform: translate(-50%, -50%);
  display:inline-flex; /* 永遠佔位，靠 opacity 切換 */
  align-items:center;
  justify-content:center;
  opacity: 0;
  pointer-events:none;
  transition: opacity 180ms ease, transform 180ms ease;
}

/* 切換模式：loading 顯示文字；done 顯示按鈕 */
.actionBar.mode-loading .statusText{ opacity: 1; }
.actionBar.mode-loading .confirm{
  opacity: 0;
  pointer-events:none;
  transform: translate(-50%, -50%) scale(0.98);
}

.actionBar.mode-done .statusText{ opacity: 0; }
.actionBar.mode-done .confirm{
  opacity: 1;
  pointer-events:auto;
  transform: translate(-50%, -50%) scale(1);
}

/* 小小按鈕進場質感 */
.actionBar.mode-done .confirm{
  box-shadow: 0 18px 45px rgba(0,0,0,0.35);
}
.confirm{
      border:0;
      border-radius: 999px;
      padding: 12px 26px;
      font-size: 16px;
      font-weight: 950;
      cursor:pointer;
      background: linear-gradient(135deg, #ffde88, #caa54a);
      color:#111;
      display:none;
    }
    .card.broken{
      outline: 2px solid rgba(255, 80, 80, 0.75);
    }
    .broken-debug{
      position:absolute;
      left:8px;
      right:8px;
      bottom:8px;
      font-size:12px;
      line-height:1.2;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.55);
      padding:6px 8px;
      border-radius:10px;
      word-break: break-all;
    }

    /* ===== V2 Cinematic Reveal (rarity hype) ===== */
    .cinematic{
      position:fixed;
      inset:0;
      z-index: 99999;
      display:none;
      align-items:center;
      justify-content:center;
      pointer-events:auto; /* cinematic handles close */
      padding: 18px;
    }
    .cinematic.show{ display:flex; }
    .cinematic .cine-bg{
      cursor:pointer;

      position:absolute; inset:0;
      background: radial-gradient(circle at center, rgba(0,0,0,0.55), rgba(0,0,0,0.92));
      backdrop-filter: blur(2px);
    }
    .cinematic .cine-black{
      position:absolute; inset:0;
      background:#000;
      opacity:0;
    }
    .cinematic.black .cine-black{ opacity:1; }
    .cinematic .cine-flash{
      position:absolute; inset:0;
      background: rgba(255,255,255,0.95);
      opacity:0;
      mix-blend-mode: screen;
    }
    .cinematic.flash .cine-flash{
      animation: cineFlash 520ms ease-out 1;
    }
    @keyframes cineFlash{
      0%{ opacity:0; }
      12%{ opacity:1; }
      100%{ opacity:0; }
    }

    .cinematic .cine-shake{
      position:absolute; inset:0;
    }
    .cinematic.shake .cine-shake{
      animation: cineShake 520ms ease-in-out 1;
    }
    @keyframes cineShake{
      0%{ transform: translate(0,0); }
      15%{ transform: translate(-4px, 2px); }
      30%{ transform: translate(4px, -2px); }
      45%{ transform: translate(-3px, -1px); }
      60%{ transform: translate(3px, 1px); }
      100%{ transform: translate(0,0); }
    }

    .cinematic .cine-core{
      pointer-events:auto;

      position:relative;
      z-index: 2;
      width: min(820px, 92vw);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 14px;
      padding: 24px 18px 18px;
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,0.12);
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,0.08), transparent 55%),
        radial-gradient(circle at 70% 80%, rgba(121,215,255,0.06), transparent 55%),
        rgba(15,18,26,0.82);
      box-shadow: 0 30px 140px rgba(0,0,0,0.78);
      overflow:hidden;
    }

    .cine-rarity{
      font-weight: 1000;
      letter-spacing: 1px;
      font-size: clamp(24px, 4vw, 44px);
      line-height: 1;
      text-shadow: 0 10px 30px rgba(0,0,0,0.65);
      opacity: 0;
      transform: translateY(8px) scale(0.98);
    }
    .cinematic.show .cine-rarity{
      animation: cineTextIn 680ms cubic-bezier(.2,.9,.2,1) 1 forwards;
    }
    @keyframes cineTextIn{
      0%{ opacity:0; transform: translateY(10px) scale(0.98); }
      55%{ opacity:1; transform: translateY(0) scale(1.02); }
      100%{ opacity:1; transform: translateY(0) scale(1); }
    }

    .cine-sub{
      opacity: 0.82;
      font-size: 13px;
      font-weight: 800;
      letter-spacing: 0.3px;
    }

    .cine-card{
      width: min(520px, 86vw);
      aspect-ratio: 1 / 1;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      box-shadow: 0 24px 90px rgba(0,0,0,0.65);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      position:relative;
    }
    .cine-card::before{
      content:"";
      position:absolute;
      inset:-55%;
      background:
        radial-gradient(circle at 25% 20%, rgba(255,255,255,0.16), transparent 55%),
        radial-gradient(circle at 70% 75%, rgba(121,215,255,0.12), transparent 60%),
        radial-gradient(circle at 45% 70%, rgba(255,198,106,0.12), transparent 60%);
      filter: blur(12px);
      transform: rotate(18deg);
      opacity: 0.85;
    }
    .cine-card img{
      width: 94%;
      height: 94%;
      object-fit: contain;
      display:block;
      position:relative;
      z-index:1;
      transform: scale(0.96);
      opacity: 0;
    }
    .cinematic.show .cine-card img{
      animation: cineCardIn 820ms cubic-bezier(.2,.9,.2,1) 1 forwards;
    }
    @keyframes cineCardIn{
      0%{ opacity:0; transform: scale(0.92); }
      55%{ opacity:1; transform: scale(1.03); }
      100%{ opacity:1; transform: scale(1.00); }
    }
    .cinematic.float .cine-card img{
      animation: cineFloat 3.2s ease-in-out infinite;
    }
    @keyframes cineFloat{
      0%{ transform: translateY(0) scale(1); }
      50%{ transform: translateY(-10px) scale(1.01); }
      100%{ transform: translateY(0) scale(1); }
    }

    .cinematic .cine-glow{
      position:absolute;
      inset: calc(18px + 0px);
      border-radius: 28px;
      pointer-events:none;
      opacity: 0;
      z-index: 3;
    }
    .cinematic.show .cine-glow{ opacity: 1; }

    /* rarity themes */
    .cinematic.r1 .cine-glow{ box-shadow: 0 0 0 1px rgba(148,163,184,0.35), 0 0 35px rgba(148,163,184,0.22); }
    .cinematic.r2 .cine-glow{ box-shadow: 0 0 0 1px rgba(34,197,94,0.35), 0 0 40px rgba(34,197,94,0.22); }
    .cinematic.r3 .cine-glow{ box-shadow: 0 0 0 1px rgba(59,130,246,0.35), 0 0 55px rgba(59,130,246,0.24); }
    .cinematic.r4 .cine-glow{ box-shadow: 0 0 0 1px rgba(168,85,247,0.38), 0 0 80px rgba(168,85,247,0.30); }
    .cinematic.r5 .cine-glow{ box-shadow: 0 0 0 1px rgba(245,158,11,0.45), 0 0 110px rgba(245,158,11,0.34), 0 0 180px rgba(255,255,255,0.18); }

    .cinematic.r4 .cine-rarity{ color: #c084fc; }
    .cinematic.r5 .cine-rarity{ color: #fbbf24; }
    .cinematic.r3 .cine-rarity{ color: #60a5fa; }
    .cinematic.r2 .cine-rarity{ color: #34d399; }
    .cinematic.r1 .cine-rarity{ color: rgba(148,163,184,0.95); }

    
    .cine-ten{
      width: 100%;
      max-width: min(760px, 92vw);
      display:none;
      flex-direction:column;
      gap:10px;
      margin-top: 2px;
    }
    .cine-ten.show{ display:flex; }
    .cine-ten-title{
      font-size: 12px;
      font-weight: 900;
      opacity: 0.85;
      letter-spacing: 0.4px;
      text-align:center;
    }
    .cine-ten-grid{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap: 10px;
      width: 100%;
      padding: 8px 2px 0;
    }
    .cine-ten-item{
      position:relative;
      border-radius: 12px;
      overflow:hidden;
      background: rgba(0,0,0,0.22);
      border: 2px solid rgba(255,255,255,0.10);
      aspect-ratio: 2 / 3;
      width: 84px;
      flex: 0 0 84px;
    }
    @media (max-width: 940px){
      .cine-ten-item{ width: 78px; flex-basis: 78px; }
    }
    @media (max-width: 520px){
      .cine-ten-item{ width: 70px; flex-basis: 70px; }
    }
    .cine-ten-item img{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit: contain;
      display:block;
      filter: saturate(0.95) contrast(1.05);
      opacity: 0.96;
    }
    .cine-ten-item.best{
      transform: translateY(-1px);
      box-shadow: 0 0 0 2px rgba(255,215,0,0.95), 0 0 18px rgba(255,215,0,0.30);
      border-color: rgba(255,215,0,0.55);
    }
    .cine-ten-item .tag{
      position:absolute;
      left: 6px;
      top: 6px;
      font-size: 10px;
      font-weight: 950;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(0,0,0,0.60);
      border: 1px solid rgba(255,255,255,0.14);
      letter-spacing: 0.3px;
      opacity: 0.95;
    }
    .cine-ten-item.r3 .tag{ color: #60a5fa; border-color: rgba(96,165,250,0.35); }
    .cine-ten-item.r4 .tag{ color: #c084fc; border-color: rgba(192,132,252,0.35); }
    .cine-ten-item.r5 .tag{ color: #fbbf24; border-color: rgba(251,191,36,0.42); }

    /* Ten-pull full-card rarity frame + badge colors (non-head/body) */
    .cine-ten-item.full{ border-width: 2px; }
    .cine-ten-item.full.r1{ border-color: rgba(34,197,94,0.95); box-shadow: 0 0 0 2px rgba(34,197,94,0.22), 0 0 18px rgba(34,197,94,0.18); }
    .cine-ten-item.full.r2{ border-color: rgba(59,130,246,0.95); box-shadow: 0 0 0 2px rgba(59,130,246,0.22), 0 0 18px rgba(59,130,246,0.18); }
    .cine-ten-item.full.r3{ border-color: rgba(168,85,247,0.95); box-shadow: 0 0 0 2px rgba(168,85,247,0.24), 0 0 22px rgba(168,85,247,0.22); }
    .cine-ten-item.full.r4{ border-color: rgba(251,146,60,0.98); box-shadow: 0 0 0 2px rgba(251,146,60,0.28), 0 0 28px rgba(251,146,60,0.28), 0 0 64px rgba(251,146,60,0.18); }
    .cine-ten-item.full.r5{ border-color: rgba(239,68,68,0.98); box-shadow: 0 0 0 2px rgba(239,68,68,0.30), 0 0 34px rgba(239,68,68,0.30), 0 0 90px rgba(239,68,68,0.20); }

    .cine-ten-item.full .tag{
      background: rgba(0,0,0,0.72);
      border-width: 2px;
    }
    .cine-ten-item.full.r1 .tag{ color: rgba(34,197,94,1); border-color: rgba(34,197,94,0.70); }
    .cine-ten-item.full.r2 .tag{ color: rgba(59,130,246,1); border-color: rgba(59,130,246,0.70); }
    .cine-ten-item.full.r3 .tag{ color: rgba(168,85,247,1); border-color: rgba(168,85,247,0.70); }
    .cine-ten-item.full.r4 .tag{ color: rgba(251,146,60,1); border-color: rgba(251,146,60,0.75); }
    .cine-ten-item.full.r5 .tag{ color: rgba(239,68,68,1); border-color: rgba(239,68,68,0.80); }


    .cine-ok{
      margin-top: 2px;
      border: 0;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 15px;
      font-weight: 1000;
      letter-spacing: 0.5px;
      cursor: pointer;
      color: #0a0f18;
      background: linear-gradient(135deg, rgba(255,198,106,0.98), rgba(255,159,47,0.98));
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
      user-select:none;
    }
    .cine-ok:active{ transform: translateY(1px); }

    .cine-cta{
      margin-top: 6px;
      font-size: 13px;
      font-weight: 900;
      opacity: 0.0;
      transform: translateY(6px);
    }
    .cinematic.cta .cine-cta{
      opacity: 0.92;
      transform: translateY(0);
      transition: 220ms ease;
    }

  
    /* pack hit flash */
    .packFlash{
      position:fixed;
      inset:0;
      z-index: 9998;
      pointer-events:none;
      opacity:0;
      background: rgba(255,255,255,0.0);
      mix-blend-mode: screen;
    }
    .packFlash.play{
      animation: packFlash 420ms ease-out 1;
    }
    @keyframes packFlash{
      0%{ opacity:0; }
      12%{ opacity:0.85; }
      100%{ opacity:0; }
    }
    .packShake{
      animation: packShake 420ms ease-in-out 1;
    }
    @keyframes packShake{
      0%{ transform: translate(0,0); }
      15%{ transform: translate(-3px, 2px); }
      30%{ transform: translate(3px, -2px); }
      45%{ transform: translate(-2px, -1px); }
      60%{ transform: translate(2px, 1px); }
      100%{ transform: translate(0,0); }
    }

  
    /* V2 clarity: show exactly which card is landing */
    .cell.focus::after{
      content:"";
      position:absolute;
      inset:-4px;
      border-radius:16px;
      box-shadow: 0 0 0 3px rgba(255,255,255,0.22), 0 0 26px rgba(255,255,255,0.22);
      pointer-events:none;
      z-index: 6;
      animation: focusPop 260ms ease-out 1;
    }
    @keyframes focusPop{
      0%{ transform: scale(0.98); opacity: 0.0; }
      25%{ opacity: 1.0; }
      100%{ transform: scale(1.00); opacity: 0.0; }
    }

    /* Cinematic 10-pull layout: guarantee on top */
    .cine-ten{ width:min(860px, 92vw); }
    .cine-ten-subtitle{
      margin: 10px 0 8px;
      font-size: 12px;
      font-weight: 950;
      letter-spacing: 0.6px;
      opacity: 0.86;
      text-align:center;
    }
    .cine-ten-g{
      display:flex;
      align-items:center;
      justify-content:center;
      margin-bottom: 6px;
    }
    .cine-ten-g .cine-ten-item{
      width: 132px;
      height: 196px;
      border-radius: 18px;
    }

  
/* ===== EXTREME SSR / UR EFFECT BOOST ===== */
.card.rarity-ssr,
.result-card.rarity-ssr{
  position:relative;
  animation:ssrPulse 1.4s ease-in-out infinite;
  box-shadow:
    0 0 14px rgba(168,85,247,1),
    0 0 32px rgba(168,85,247,0.9),
    0 0 80px rgba(168,85,247,0.7);
}
.card.rarity-ssr::after,
.result-card.rarity-ssr::after{
  content:"";
  position:absolute;
  inset:-4px;
  border-radius:16px;
  border:2px solid rgba(192,132,252,1);
  animation:ssrRing 1.8s linear infinite;
}
@keyframes ssrPulse{
  0%,100%{ transform:scale(1);}
  50%{ transform:scale(1.06);}
}
@keyframes ssrRing{
  0%{ opacity:1; transform:scale(1);}
  50%{ opacity:.3; transform:scale(1.12);}
  100%{ opacity:1; transform:scale(1);}
}

.card.rarity-ur,
.result-card.rarity-ur{
  position:relative;
  animation:urPulse 1.0s ease-in-out infinite;
  box-shadow:
    0 0 18px gold,
    0 0 50px rgba(255,200,0,1),
    0 0 120px rgba(255,200,0,0.9),
    0 0 200px rgba(255,255,255,0.7);
}
.card.rarity-ur::before,
.result-card.rarity-ur::before{
  content:"";
  position:absolute;
  inset:-8px;
  border-radius:20px;
  border:3px solid gold;
  animation:urRing 1.2s linear infinite;
}
.card.rarity-ur::after,
.result-card.rarity-ur::after{
  content:"";
  position:absolute;
  inset:-18px;
  border-radius:24px;
  background: radial-gradient(circle, rgba(255,215,0,1), transparent 70%);
  filter:blur(12px);
  animation:urAura 1.8s ease-in-out infinite;
}
@keyframes urPulse{
  0%,100%{ transform:scale(1);}
  50%{ transform:scale(1.1);}
}
@keyframes urRing{
  0%{ transform:rotate(0deg);}
  100%{ transform:rotate(360deg);}
}
@keyframes urAura{
  0%,100%{ opacity:.8; transform:scale(1);}
  50%{ opacity:1; transform:scale(1.15);}
}

/* center bottom cards */
.results-bottom,
.results-grid,
.results-row{
  display:flex !important;
  justify-content:center !important;
  align-items:center;
  flex-wrap:wrap;
  gap:14px;
  width:100%;
}


    /* ===== Share Card ===== */
    .sharePanel{
      margin-top: 12px;
      width: min(520px, 92vw);
      border-radius: 18px;
      padding: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 18px 60px rgba(0,0,0,0.50);
    }
    .shareTitle{
      font-weight: 1000;
      letter-spacing: 0.4px;
      opacity: 0.92;
      margin-bottom: 10px;
      text-align: left;
    }
    .shareBody{
      display:flex;
      gap: 12px;
      align-items: stretch;
    }
    #sharePreview{
      width: 150px;
      height: 150px;
      border-radius: 14px;
      object-fit: cover;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      flex: 0 0 auto;
    }
    .shareBtns{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
      align-content: flex-start;
    }
    .shareBtn{
      border: 0;
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 900;
      cursor: pointer;
      background: rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
      user-select:none;
    }
    .shareBtn:hover{ background: rgba(255,255,255,0.16); }
    .shareBtn:active{ transform: translateY(1px); }
    .shareBtn.shareClaim{
      background: linear-gradient(135deg, rgba(255,198,106,0.98), rgba(255,159,47,0.98));
      color: #0a0f18;
    }
    .shareHint{
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.80;
      line-height: 1.35;
      text-align: left;
    }
    @media (max-width: 520px){
      .shareBody{ flex-direction: column; }
      #sharePreview{ width: 100%; height: 180px; }
    }

  </style>
</head>
<body>
  <div class="packFlash" id="packFlash"></div>
  <div class="wrap">
    <h1>本期 Featured 角色</h1>

    <div class="heroGrid">
      <div>
        <div class="featured">
          <div class="badge">
            <span style="opacity:0.8">feature</span>
          </div>

          <div class="featureStage">
            <div class="promoTag" aria-hidden="true">
              <div class="promoBig">素材獲得機率+300%</div>
              <div class="promoBoom">爆款</div>
            </div>

            <video id="featuredVideo" muted autoplay loop playsinline></video>
            <img id="featuredFallback" src="/assets/feature_character.png" alt="" style="display:none;">

            <div class="gachaOverlay">
              <div class="gachaCard">
                <div class="gachaHead">
                  <div class="gachaName">普通抽卡</div>
                  <div class="gachaDesc">單次 或 10 連抽</div>
                </div>

                <div class="drawRow">
                  <div class="drawCol">
                    <button class="btn orange small" id="btnNormal1">1次</button>
                    <div class="cost">cost 100gold</div>
                  </div>
                  <div class="drawCol">
                    <button class="btn orange small" id="btnNormal10">10次</button>
                    <div class="cost">cost 1000gold</div>
                    <div class="guarantee">必出SR以上</div>
                  </div>
                </div>

                <div class="pity" id="pityNormal">再抽200次 必出SSR</div>
              </div>

              <div class="gachaCard">
                <div class="gachaHead">
                  <div class="gachaName">高級抽卡</div>
                  <div class="gachaDesc">單次 或 10 連抽</div>
                </div>

                <div class="drawRow">
                  <div class="drawCol">
                    <button class="btn blue small" id="btnPremium1">1次</button>
                    <div class="cost">cost 10gem</div>
                  </div>
                  <div class="drawCol">
                    <button class="btn blue small" id="btnPremium10">10次</button>
                    <div class="cost">cost 100gem</div>
                    <div class="guarantee">必出SSR以上</div>
                  </div>
                </div>

                <div class="pity" id="pityPremium">再抽200次 必出UR</div>
              </div>
            </div>
          </div>
        </div>

      </div>

      <div class="side">
        <div class="sideCard">
          <div class="title"><span>抽角色</span><span style="opacity:0.7;font-weight:800">head</span></div>
          <div class="miniRow">
            <button class="btn gray small" id="btnHead1">1次</button>
            <button class="btn gray small" id="btnHead10">10次</button>
          </div>
        </div>

        <div class="sideCard">
          <div class="title"><span>抽服裝</span><span style="opacity:0.7;font-weight:800">body</span></div>
          <div class="miniRow">
            <button class="btn gray small" id="btnBody1">1次</button>
            <button class="btn gray small" id="btnBody10">10次</button>
          </div>
        </div>

        <div class="sideCard">
          <div class="title"><span>抽背景</span><span style="opacity:0.7;font-weight:800">background</span></div>
          <div class="miniRow">
            <button class="btn gray small" id="btnBg1">1次</button>
            <button class="btn gray small" id="btnBg10">10次</button>
          </div>
        </div>

        <div class="sideCard">
          <div class="title"><span>抽特效1</span><span style="opacity:0.7;font-weight:800">addon1</span></div>
          <div class="miniRow">
            <button class="btn gray small" id="btnAddon11">1次</button>
            <button class="btn gray small" id="btnAddon110">10次</button>
          </div>
        </div>

        <div class="sideCard">
          <div class="title"><span>抽特效2</span><span style="opacity:0.7;font-weight:800">addon2</span></div>
          <div class="miniRow">
            <button class="btn gray small" id="btnAddon21">1次</button>
            <button class="btn gray small" id="btnAddon210">10次</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
            <div class="gacha-stage">
        <div class="grid32" id="grid32"></div>
        <div class="framesLayer" id="framesLayer"></div>
        <div class="loadCover" id="loadCover"><div class="spinner"></div><div class="txt" id="loadTxt">載入中</div></div>
      </div>

      <div class="actionBar mode-loading" id="actionBar">
        <div class="statusText">
          <div id="rollingText">抽卡中</div>
          <div id="rollSub" class="muted" style="display:none;"></div>
        </div>
        <button class="confirm" id="confirmBtn">確認</button>
      </div>

  </div>

  <script src="app.js"></script>
  <script>

    // featured video: load from DB season featured table
    
async function loadFeaturedVideo(){
  const v = document.getElementById("featuredVideo");
  const img = document.getElementById("featuredFallback");
  if(!v) return;

  // Ensure autoplay works on mobile
  v.muted = true;
  v.autoplay = true;
  v.loop = true;
  v.playsInline = true;
  v.setAttribute("playsinline", "");
  v.preload = "auto";

  const showFallback = ()=>{
    try{ v.pause(); }catch(_){}
    try{ v.removeAttribute("src"); }catch(_){}
    try{ v.load(); }catch(_){}
    v.style.display = "none";
    if(img) img.style.display = "";
  };

  const normalizeFeaturedList = (data)=>{
    if(!data) return [];
    if(Array.isArray(data)) return data;
    if(Array.isArray(data.featured)) return data.featured;
    if(Array.isArray(data.items)) return data.items;
    if(Array.isArray(data.data)) return data.data;
    return [];
  };

  // Some builds have window.api() that returns JSON (not a fetch Response).
  // This wrapper accepts either style.
  const getJson = async (path)=>{
    if(typeof window.api === "function"){
      const r = await window.api(path, { method: "GET" });
      // If r is already a JSON object, return it.
      if(r && typeof r === "object" && typeof r.json !== "function") return r;
      // If r looks like a Response, parse it.
      if(r && typeof r.json === "function") return await r.json();
    }
    const res = await fetch(path, { cache: "no-store" });
    if(!res.ok) throw new Error(`http_${res.status}`);
    return await res.json();
  };

  try{
    const seasonId = (window.SEASON_ID || "S1");
    const data = await getJson(`/api/featured?seasonId=${encodeURIComponent(seasonId)}`);
    const list = normalizeFeaturedList(data);
    const first = list[0] || null;
    const fid = first && (first.featuredId || first.id || first.assetId || first.featured_id);
    if(!fid) throw new Error("no_featuredId");

    // Prefer explicit videoUrl returned by backend; fallback to /assets/[featuredId].mp4
    let src = "";
    const vurl = first && (first.videoUrl || first.video_url || first.mp4Url || first.mp4_url || first.url);
    if(vurl) src = String(vurl);
    if(!src) src = `/assets/${fid}.mp4`;

    // Always load assets from this page origin (Pages), not the Worker origin.
    if(!/^https?:\/\//i.test(src)){
      if(src.startsWith("assets/")) src = "/" + src;
      if(!src.startsWith("/")) src = "/" + src;
      src = `${location.origin}${src}`;
    }

    v.onerror = showFallback;
    v.src = src;
    v.style.display = "";
    if(img) img.style.display = "none";

    try{ v.load(); }catch(_){}
    v.play().catch(()=>{});
  }catch(e){
    console.warn("featured video load failed", e);
    showFallback();
  }
}
    const overlay = document.getElementById("overlay");
    const grid32El = document.getElementById("grid32");
    const framesLayer = document.getElementById("framesLayer");
    const loadCover = document.getElementById("loadCover");
    const loadTxt = document.getElementById("loadTxt");
    const rollSub = document.getElementById("rollSub");
    const rollingText = document.getElementById("rollingText");
    const confirmBtn = document.getElementById("confirmBtn");
    const actionBar = document.getElementById("actionBar");

    function showLoad(msg){
      if(loadTxt) loadTxt.textContent = msg || "載入中";
      if(loadCover) loadCover.classList.add("show");
      const stage = loadCover && loadCover.closest(".gacha-stage");
      if(stage) stage.classList.add("loading");
    }
    function hideLoad(){
      if(loadCover) loadCover.classList.remove("show");
      const stage = loadCover && loadCover.closest(".gacha-stage");
      if(stage) stage.classList.remove("loading");
    }
    function preloadImages(urls, timeoutMs=8000){
      const uniq = Array.from(new Set((urls||[]).filter(Boolean)));
      if(uniq.length === 0) return Promise.resolve();
      return new Promise((resolve)=>{
        let done = 0;
        const total = uniq.length;
        const finish = ()=>{ done++; if(done>=total) resolve(); };
        setTimeout(()=>resolve(), timeoutMs);
        uniq.forEach(u=>{
          const img = new Image();
          img.onload = finish;
          img.onerror = finish;
          img.src = u;
        });
      });
    }


    const btnNormal1 = document.getElementById("btnNormal1");
    const btnNormal10 = document.getElementById("btnNormal10");
    const btnPremium1 = document.getElementById("btnPremium1");
    const btnPremium10 = document.getElementById("btnPremium10");

    const btnHead1 = document.getElementById("btnHead1");
    const btnHead10 = document.getElementById("btnHead10");
    const btnBody1 = document.getElementById("btnBody1");
    const btnBody10 = document.getElementById("btnBody10");
    const btnBg1 = document.getElementById("btnBg1");
    const btnBg10 = document.getElementById("btnBg10");
    const btnAddon11 = document.getElementById("btnAddon11");
    const btnAddon110 = document.getElementById("btnAddon110");
    const btnAddon21 = document.getElementById("btnAddon21");
    const btnAddon210 = document.getElementById("btnAddon210");

    let animating = false;
    let cachedAssets = null;

    function showOverlay(){ overlay.classList.add("show"); }
    function hideOverlay(){
      overlay.classList.remove("show");
      // reset overlay state
      framesLayer.innerHTML = "";
       hideCinematic();
      grid32El.querySelectorAll(".cell").forEach(c=>c.classList.remove("dim","win","win2","red"));
      if(rollingText) rollingText.style.display = "";
      if(rollSub){ rollSub.style.display = "none"; rollSub.textContent = ""; }
      if(actionBar){ actionBar.classList.add("mode-loading"); actionBar.classList.remove("mode-done"); }
      if(confirmBtn){ confirmBtn.style.opacity="0"; confirmBtn.style.pointerEvents="none"; }
    }

    confirmBtn.addEventListener("click", () => { hideCinematic(); hideOverlay(); });
function normalizeType(t){
      const x = String(t||"");
      if(x === "bg") return "background";
      if(x === "background") return "background";
      if(x === "addon1") return "addon1";
      if(x === "addon2") return "addon2";
      return x;
    }

    function requestType(t){
      const x = String(t||"");
      if(x === "background") return "bg";
      return x;
    }

    function toThumbIfNeeded(asset){
      if(!asset || !asset.imageUrl) return "";
      const t = String(asset.type || "");
      if(t === "head" || t === "body"){
        if(String(asset.imageUrl).includes("_thumb.")) return asset.imageUrl;
        return String(asset.imageUrl).replace(/\.(png|webp|jpg|jpeg)$/i, "_thumb.$1");
      }
      return asset.imageUrl;
    }

    async function ensureAssetsLoaded(){
      if(cachedAssets) return cachedAssets;
      const data = await api("/api/assets");
      if(data && data.ok && Array.isArray(data.assets)){
        cachedAssets = data.assets;
        return cachedAssets;
      }
      throw new Error("assets_load_failed");
    }
async function onlineGacha(opts = {}) {
  // Use the same routing as the rest of the project:
  // - If app.js provides window.api(), it likely routes to the Worker origin.
  // - Otherwise fall back to same-origin fetch.
  const apiFetch = (url, fetchOpts) => {
    if (typeof window.api === "function") return window.api(url, fetchOpts);
    return fetch(url, fetchOpts);
  };

  const payload = {
    count: Number(opts.count || 1),
    premium: !!opts.premium,
    type: opts.type ? requestType(opts.type) : undefined,
    seasonId: String(opts.seasonId || "S1"),
  };

  const headers = { "content-type": "application/json" };

  // Try to attach uid if we can find it (keeps behavior consistent with other pages)
  const uidCandidates = [
    window.USER_ID,
    window.userId,
    window.uid,
    (typeof window.getUserId === "function" ? window.getUserId() : ""),
    (typeof window.getUid === "function" ? window.getUid() : ""),
    localStorage.getItem("uid"),
    localStorage.getItem("userId"),
    localStorage.getItem("USER_ID"),
  ];
  for (const v of uidCandidates) {
    const s = String(v || "").trim();
    if (s && s !== "null" && s !== "undefined") { headers["x-user-id"] = s; break; }
  }

  const resp = await apiFetch("/api/gacha", {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  // Some wrappers may return JSON directly instead of a Response.
  const isResponseLike = resp && typeof resp === "object" && ("ok" in resp) && typeof resp.json === "function";
  if (isResponseLike) {
    if (!resp.ok) {
      let err = null;
      try{ err = await resp.json(); }catch(_){ }
      const code = err && err.error ? String(err.error) : `gacha_http_${resp.status}`;
      const need = err && (err.need || err.costGold || err.costGem) ? Number(err.need || err.costGold || err.costGem) : null;
      const have = err && (err.have || err.userGold || err.userGem) ? Number(err.have || err.userGold || err.userGem) : null;
      const msg = (need !== null && have !== null) ? `${code} (need ${need}, have ${have})` : code;
      throw new Error(msg);
    }
    const data = await resp.json();
    if (!data || !data.ok || !Array.isArray(data.pulled)) throw new Error("gacha_failed");
    if (opts.type) {
      const want = String(requestType(opts.type)).toLowerCase();
      data.pulled = data.pulled.filter((a) => String(a?.type || "").toLowerCase() === want);
    }
    return data;
  } else {
    const data = resp; // already JSON
    if (!data || !data.ok || !Array.isArray(data.pulled)) throw new Error("gacha_failed");
    if (opts.type) {
      const want = String(requestType(opts.type)).toLowerCase();
      data.pulled = data.pulled.filter((a) => String(a?.type || "").toLowerCase() === want);
    }
    return data;
  }


function setPityText(el, remaining, label){
  if(!el) return;
  const x = Math.max(1, Number(remaining || 0));
  el.textContent = `再抽${x}次 必出${label}`;
}

function updatePityUI(data){
  if(!data) return;
  const n = data.pityNormalRemaining;
  const p = data.pityPremiumRemaining;
  setPityText(document.getElementById("pityNormal"), n, "SSR");
  setPityText(document.getElementById("pityPremium"), p, "UR");
}

async function loadPityStatus(){
  const apiFetch = (url, fetchOpts) => {
    if (typeof window.api === "function") return window.api(url, fetchOpts);
    return fetch(url, fetchOpts);
  };

  const headers = {};
  const uidCandidates = [
    window.USER_ID,
    window.userId,
    window.uid,
    (typeof window.getUserId === "function" ? window.getUserId() : ""),
    (typeof window.getUid === "function" ? window.getUid() : ""),
    localStorage.getItem("uid"),
    localStorage.getItem("userId"),
    localStorage.getItem("USER_ID"),
  ];
  for (const v of uidCandidates) {
    const s = String(v || "").trim();
    if (s && s !== "null" && s !== "undefined") { headers["x-user-id"] = s; break; }
  }

  try{
    const resp = await apiFetch("/api/gacha/pity", { method:"GET", headers });
    const isResponseLike = resp && typeof resp === "object" && ("ok" in resp) && typeof resp.json === "function";
    const data = isResponseLike ? await resp.json() : resp;
    if(data && data.ok) updatePityUI(data);
  }catch(_){}
}}

    function assetThumb(a){
      if(!a) return "/assets/placeholder.png";
      if(a.thumb) return a.thumb;
      if(a.imageUrl) return toThumbIfNeeded(a);
      if(a.id) return `/assets/${a.id}.png`;
      return "/assets/placeholder.png";
    }

    function assetLabel(a){
      if(!a) return "";
      const id = a.id || a.assetId || "";
      const r = Number(a.rarity || 1);
      return `${id}  R${r}`;
    }

    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }


    const RARITY_NAME = {1:"C",2:"R",3:"SR",4:"SSR",5:"UR"};

    // Simple WebAudio SFX (no external files)
    let _audioCtx = null;
    function _ctx(){
      try{
        _audioCtx = _audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        return _audioCtx;
      }catch(_){ return null; }
    }
    function playTone(freq, dur=0.12, type="sine", gain=0.06, when=0){
      const ctx = _ctx();
      if(!ctx) return;
      const t0 = ctx.currentTime + (when||0);
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(ctx.destination);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }
    function sfxByRarity(r){
      const rr = Number(r||1);
      if(rr >= 5){
        // UR: heartbeat + lift
        playTone(70, 0.10, "sine", 0.10, 0.00);
        playTone(70, 0.10, "sine", 0.10, 0.18);
        playTone(220, 0.10, "triangle", 0.10, 0.40);
        playTone(330, 0.14, "triangle", 0.10, 0.52);
        playTone(520, 0.16, "sawtooth", 0.08, 0.66);
        return;
      }
      if(rr === 4){
        playTone(180, 0.10, "triangle", 0.08, 0.00);
        playTone(260, 0.12, "triangle", 0.08, 0.12);
        playTone(420, 0.14, "sawtooth", 0.06, 0.26);
        return;
      }
      if(rr === 3){
        playTone(240, 0.10, "sine", 0.06, 0.00);
        playTone(360, 0.12, "triangle", 0.05, 0.12);
        return;
      }
      if(rr === 2){
        playTone(260, 0.08, "sine", 0.04, 0.00);
        return;
      }
      playTone(220, 0.06, "sine", 0.03, 0.00);
    }

    
    function packHitFx(r){
      const el = document.getElementById("packFlash");
      if(!el) return;
      const rr = Math.max(1, Math.min(5, Number(r||1)));
      // color by rarity
      let bg = "rgba(255,255,255,0.85)";
      if(rr === 1) bg = "rgba(148,163,184,0.55)";
      if(rr === 2) bg = "rgba(34,197,94,0.55)";
      if(rr === 3) bg = "rgba(59,130,246,0.60)";
      if(rr === 4) bg = "rgba(168,85,247,0.65)";
      if(rr === 5) bg = "rgba(245,158,11,0.70)";
      el.style.background = bg;
      el.classList.remove("play");
      void el.offsetWidth;
      el.classList.add("play");

      // shake the panel a bit on SSR/UR
      const p = document.querySelector(".panel");
      if(p && rr >= 4){
        p.classList.remove("packShake");
        void p.offsetWidth;
        p.classList.add("packShake");
      }
    }

function assetFullUrl(a){
      if(!a) return "/assets/placeholder.png";
      if(a.imageUrl) return String(a.imageUrl);
      const id = a.id || a.assetId || "";
      if(id) return `/assets/${id}.png`;
      return "/assets/placeholder.png";
    }

    
    async function playCinematicForPack(winners, isTen){
      const cinematic = document.getElementById("cinematic");
      const cineRarity = document.getElementById("cineRarity");
      const cineSub = document.getElementById("cineSub");
      const cineImg = document.getElementById("cineImg");
      const cineTen = document.getElementById("cineTen");
      const cineTenGrid = document.getElementById("cineTenGrid");
      const cineOk = document.getElementById("cineOk");
      const cineCta = document.getElementById("cineCta");
      const sharePanel = document.getElementById("sharePanel");
      const shareCanvas = document.getElementById("shareCanvas");
      const sharePreview = document.getElementById("sharePreview");
      const shareDownload = document.getElementById("shareDownload");
      const shareCopy = document.getElementById("shareCopy");
      const shareShare = document.getElementById("shareShare");
      const shareReddit = document.getElementById("shareReddit");
      const shareClaim = document.getElementById("shareClaim");
      const shareHint = document.getElementById("shareHint");

      let _shareState = { ready:false, blob:null, dataUrl:"", caption:"", shareId:"", rarity:0, assetId:"" };

      function buildUidHeaders(){
        const headers = { "content-type": "application/json" };
        const uidCandidates = [
          window.USER_ID,
          window.userId,
          window.uid,
          (typeof window.getUserId === "function" ? window.getUserId() : ""),
          (typeof window.getUid === "function" ? window.getUid() : ""),
          localStorage.getItem("uid"),
          localStorage.getItem("userId"),
          localStorage.getItem("USER_ID"),
        ];
        for (const v of uidCandidates) {
          const s = String(v || "").trim();
          if (s && s !== "null" && s !== "undefined") { headers["x-user-id"] = s; break; }
        }
        return headers;
      }

      async function getMyAccount(){
        try{
          const apiFetch = (url, fetchOpts) => {
            if (typeof window.api === "function") return window.api(url, fetchOpts);
            return fetch(url, fetchOpts);
          };
          const res = await apiFetch("/api/me/account", { method:"GET", headers: buildUidHeaders() });
          if(res && typeof res.json === "function"){
            if(!res.ok) return null;
            return await res.json();
          }
          if(res && typeof res === "object") return res;
        }catch(_){}
        return null;
      }

      function initialsFromName(name){
        const s = String(name || "").trim();
        if(!s) return "P";
        const parts = s.split(/\s+/).filter(Boolean);
        if(parts.length === 1) return parts[0].slice(0,2).toUpperCase();
        return (parts[0].slice(0,1) + parts[parts.length-1].slice(0,1)).toUpperCase();
      }

      function rarityBg(ctx, r){
        if(r === 5){
          const g = ctx.createLinearGradient(0,0,1080,1080);
          g.addColorStop(0, "rgba(255,60,60,1)");
          g.addColorStop(1, "rgba(120,20,20,1)");
          return g;
        }
        if(r === 4){
          const g = ctx.createLinearGradient(0,0,1080,1080);
          g.addColorStop(0, "rgba(255,185,95,1)");
          g.addColorStop(1, "rgba(155,82,20,1)");
          return g;
        }
        const g = ctx.createLinearGradient(0,0,1080,1080);
        g.addColorStop(0, "rgba(70,80,120,1)");
        g.addColorStop(1, "rgba(20,25,40,1)");
        return g;
      }

      async function loadImage(url){
        return await new Promise((resolve, reject)=>{
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = ()=>resolve(img);
          img.onerror = ()=>reject(new Error("img_load_failed"));
          img.src = url;
        });
      }

      function drawRoundRect(ctx, x,y,w,h,r){
        const rr = Math.max(0, Math.min(r, Math.min(w,h)/2));
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      async function buildShareCardImage(opts){
        if(!shareCanvas) throw new Error("no_canvas");
        const c = shareCanvas;
        const ctx = c.getContext("2d");
        if(!ctx) throw new Error("no_ctx");

        const r = Number(opts.rarity || 1);
        const rName = RARITY_NAME[r] || ("R" + r);
        const assetId = String(opts.assetId || "");
        const gameName = String(opts.gameName || "Player");
        const avatarText = initialsFromName(gameName);

        ctx.clearRect(0,0,c.width,c.height);

        ctx.fillStyle = rarityBg(ctx, r);
        ctx.fillRect(0,0,c.width,c.height);

        // soft vignette
        const vg = ctx.createRadialGradient(540, 420, 60, 540, 540, 700);
        vg.addColorStop(0, "rgba(255,255,255,0.10)");
        vg.addColorStop(1, "rgba(0,0,0,0.55)");
        ctx.fillStyle = vg;
        ctx.fillRect(0,0,c.width,c.height);

        // title
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "900 54px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left";
        ctx.fillText("Gacha Pull", 64, 98);

        // rarity badge
        const badgeW = 210, badgeH = 78;
        const bx = 64, by = 126;
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        drawRoundRect(ctx, bx, by, badgeW, badgeH, 22);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.20)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.96)";
        ctx.font = "1000 40px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(rName, bx + 24, by + 54);

        // player badge
        const px = 64, py = 224;
        ctx.fillStyle = "rgba(0,0,0,0.32)";
        drawRoundRect(ctx, px, py, 520, 90, 26);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.16)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // avatar circle
        ctx.fillStyle = "rgba(255,255,255,0.14)";
        ctx.beginPath();
        ctx.arc(px + 52, py + 45, 30, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "900 26px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.fillText(avatarText, px + 52, py + 54);

        ctx.textAlign = "left";
        ctx.font = "900 30px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(gameName, px + 98, py + 57);

        ctx.font = "700 22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.fillText(assetId, px + 98, py + 84);

        // card image
        const img = await loadImage(opts.cardUrl);
        const cardX = 170, cardY = 330, cardW = 740, cardH = 740;

        // card shadow
        ctx.save();
        ctx.globalAlpha = 0.55;
        ctx.fillStyle = "rgba(0,0,0,1)";
        drawRoundRect(ctx, cardX + 18, cardY + 22, cardW, cardH, 44);
        ctx.fill();
        ctx.restore();

        // card frame
        ctx.fillStyle = "rgba(0,0,0,0.24)";
        drawRoundRect(ctx, cardX, cardY, cardW, cardH, 44);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.lineWidth = 3;
        ctx.stroke();

        // draw image inside
        const pad = 22;
        const ix = cardX + pad, iy = cardY + pad, iw = cardW - pad*2, ih = cardH - pad*2;

        // contain
        const s = Math.min(iw / img.width, ih / img.height);
        const dw = img.width * s;
        const dh = img.height * s;
        const dx = ix + (iw - dw)/2;
        const dy = iy + (ih - dh)/2;

        ctx.save();
        drawRoundRect(ctx, ix, iy, iw, ih, 34);
        ctx.clip();
        ctx.drawImage(img, dx, dy, dw, dh);
        ctx.restore();

        // footer
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.font = "700 20px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "left";
        const urlText = String(location.origin || "");
        ctx.fillText(urlText, 64, 1036);

        return await new Promise((resolve)=>{
          c.toBlob((blob)=>{
            if(!blob) return resolve({ blob:null, dataUrl:"" });
            const fr = new FileReader();
            fr.onload = ()=>resolve({ blob, dataUrl: String(fr.result||"") });
            fr.readAsDataURL(blob);
          }, "image/png", 0.95);
        });
      }

      function setShareHint(msg){
        if(shareHint) shareHint.textContent = msg;
      }

      if(!cinematic || !cineImg || !cineOk) return;

      const arr = Array.isArray(winners) ? winners.filter(Boolean) : [];
      if(arr.length === 0) return;

      // pick focus: best rarity, tie -> later item wins (feels like "最後一張更重要")
      let focus = arr[0];
      for(const w of arr){
        const rw = Number(w?.rarity||1);
        const rf = Number(focus?.rarity||1);
        if(rw > rf) focus = w;
        else if(rw === rf) focus = w;
      }

      const r = Math.max(1, Math.min(5, Number(focus?.rarity || 1)));
      const rName = RARITY_NAME[r] || `R${r}`;

      // Share panel only for SSR/UR
      if(sharePanel) sharePanel.style.display = (r >= 4 ? "" : "none");
      _shareState = { ready:false, blob:null, dataUrl:"", caption:"", shareId: crypto.randomUUID(), rarity:r, assetId: String(focus?.assetId || focus?.id || "") };

      if(r >= 4){
        try{
          const acc = await getMyAccount();
          const gameName = (acc && (acc.account?.userName || acc.userName || acc.account?.name)) ? String(acc.account?.userName || acc.userName || acc.account?.name) : "Player";
          const cardUrl = String(focus?.imageUrl || focus?.thumb || "");
          const { blob, dataUrl } = await buildShareCardImage({ rarity:r, assetId:_shareState.assetId, gameName, cardUrl });
          _shareState.blob = blob;
          _shareState.dataUrl = dataUrl;
          _shareState.ready = !!blob;
          _shareState.caption = `我在 ${gameName} 抽到了 ${rName} ${_shareState.assetId} \n${location.origin}`;
          if(sharePreview && dataUrl) sharePreview.src = dataUrl;
          setShareHint("點一鍵分享即可，系統會自動發放獎勵（每天最多 5 次）");
        }catch(e){
          console.warn("share build failed", e);
          setShareHint("分享圖生成失敗，仍可繼續抽卡");
          if(sharePanel) sharePanel.style.display = "none";
        }
      }

      cinematic.className = `cinematic show r${r}`;
      cinematic.setAttribute("aria-hidden","false");
      cinematic.classList.add("black");
      cinematic.classList.remove("flash","shake","float","cta");

      // Hide underlying confirm (we use cinematic confirm)
      if(confirmBtn){
        confirmBtn.style.opacity = "0.0";
        confirmBtn.style.pointerEvents = "none";
      }

      
      // Ten-pull thumbnails (SSR/UR on top)
      if(cineTen && cineTenGrid){
        cineTenGrid.innerHTML = "";
        if(cineTenGuarantee) cineTenGuarantee.innerHTML = "";
        if(isTen){
          cineTen.classList.add("show");

          // featured: all SSR/UR (rarity >= 4), keep original order
          const featured = arr.filter(w => Number(w?.rarity||1) >= 4);
          const rest = arr.filter(w => Number(w?.rarity||1) < 4);

          const addItem = (w, container, best=false) => {
            const rr = Math.max(1, Math.min(5, Number(w?.rarity || 1)));
            const t = String(w?.type || "").toLowerCase();
            const isHB = (t === "head" || t === "body");
            const item = document.createElement("div");
            item.className = `cine-ten-item r${rr}` + (best ? " best" : "") + (isHB ? " thumb" : " full");
            const img = document.createElement("img");
            // head/body: thumb only; others: use full card art
            img.src = isHB ? assetThumb(w) : assetFullUrl(w);
            img.alt = String(w?.id || w?.assetId || "");
            // If not thumb (non head/body), show rarity badge
            if(!isHB){
              const tag = document.createElement("div");
              tag.className = "tag";
              tag.textContent = RARITY_NAME[rr] || `R${rr}`;
              item.appendChild(img);
              item.appendChild(tag);
            }else{
              item.appendChild(img);
            }
            container.appendChild(item);
          };

          // top row: SSR/UR (if any). reuse cineTenGuarantee as the top container
          if(cineTenGuarantee){
            if(featured.length){
              for(const w of featured){
                addItem(w, cineTenGuarantee, (w === focus));
              }
            }else{
              // if no SSR/UR, show the best card on top for a bit of drama
              addItem(focus, cineTenGuarantee, true);
            }
          }

          // bottom grid: all remaining cards
          for(const w of rest){
            // avoid duplicating focus if it was used as fallback top card
            if(!featured.length && w === focus) continue;
            addItem(w, cineTenGrid, (w === focus));
          }
        }else{
          cineTen.classList.remove("show");
        }
      }

      // Show big card only for single pull

      const cineCardWrap = cineImg ? cineImg.closest(".cine-card") : null;
      if(cineCardWrap){
        cineCardWrap.style.display = isTen ? "none" : "";
      }

      // Text
      cineRarity.textContent = rName;
      const id = String(focus?.assetId || focus?.id || "").trim();
      cineSub.textContent = isTen ? (id ? `10連抽 最稀有：${id}` : "10連抽 結果") : (id ? `恭喜獲得 ${id}` : "恭喜獲得");
      if(cineCta) cineCta.textContent = "點擊確認繼續";

      // Image: final display
      // head/body: always use thumb (avoid heavy full image)
      // others: show thumb first, then upgrade to full when loaded
      const thumbSrc = assetThumb(focus);
      cineImg.src = thumbSrc;

      const tFocus = String(focus?.type || "");
      const allowFull = !(tFocus === "head" || tFocus === "body");
      const fullSrc = allowFull ? assetFullUrl(focus) : "";
      if(allowFull && fullSrc && fullSrc !== thumbSrc){
        const test = new Image();
        test.onload = ()=>{ cineImg.src = fullSrc; };
        test.onerror = ()=>{};
        test.src = fullSrc;
      }


      // Share actions
      const downloadShare = ()=>{
        if(!_shareState.ready || !_shareState.dataUrl) return setShareHint("分享圖還沒準備好");
        const a = document.createElement("a");
        a.href = _shareState.dataUrl;
        a.download = `gacha_${(_shareState.assetId||"card")}_${RARITY_NAME[_shareState.rarity]||_shareState.rarity}.png`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setShareHint("已下載圖片，分享到 Discord Reddit 朋友圈後點領取獎勵");
      };
      const copyCaption = async ()=>{
        try{
          await navigator.clipboard.writeText(_shareState.caption || "");
          setShareHint("已複製文案，貼到 Discord Reddit 朋友圈後點領取獎勵");
        }catch(_){
          setShareHint("複製失敗，你可以直接截圖或下載圖片分享");
        }
      };
      const systemShare = async ()=>{
        try{
          if(!_shareState.ready || !_shareState.blob) return setShareHint("分享圖還沒準備好");
          const file = new File([_shareState.blob], "gacha.png", { type:"image/png" });
          if(navigator.share){
            const data = { title:"Gacha Pull", text:_shareState.caption || "", files:[file] };
            await navigator.share(data);
            setShareHint("分享完成，獎勵發放中...");
            return;
          }
          downloadShare();
        }catch(e){
          console.warn("share failed", e);
          downloadShare();
        }
      };
      const openReddit = ()=>{
        const title = encodeURIComponent((_shareState.caption || "Gacha Pull").split("\n")[0]);
        const url = encodeURIComponent(String(location.origin || ""));
        const link = `https://www.reddit.com/submit?title=${title}&url=${url}`;
        window.open(link, "_blank", "noopener,noreferrer");
        setShareHint("Reddit 已開啟，貼上圖片後點領取獎勵");
      };
      const claimReward = async ()=>{
        try{
          if(!_shareState.ready) return setShareHint("分享圖還沒準備好");
          const apiFetch = (url, fetchOpts) => {
            if (typeof window.api === "function") return window.api(url, fetchOpts);
            return fetch(url, fetchOpts);
          };
          const res = await apiFetch("/api/share/reward", {
            method:"POST",
            headers: buildUidHeaders(),
            body: JSON.stringify({ shareId:_shareState.shareId, rarity:_shareState.rarity, assetId:_shareState.assetId }),
          });
          const data = (res && typeof res.json === "function") ? await res.json() : res;
          if(!data || !data.ok){
            const err = (data && (data.error || data.message)) ? String(data.error || data.message) : "claim_failed";
            if(err === "daily_limit") return setShareHint(`今天已領取 ${data.used || 0} 次，最多 ${data.maxPerDay || 5} 次`);
            if(err === "duplicate") return setShareHint("這張分享圖已領過獎勵");
            return setShareHint("領取失敗");
          }
          if(data.already){
            setShareHint("這張分享圖已領過獎勵");
          }else{
            const g = Number(data.reward?.gem || 0);
            const v = Number(data.reward?.vote || 0);
            setShareHint(`已領取獎勵 +${g} GEM +${v} 票 目前 GEM ${data.balances?.userGem ?? ""} 票 ${data.balances?.userVote ?? ""}`);
          }
        }catch(e){
          console.warn("claim failed", e);
          setShareHint("領取失敗");
        }
      };

            // One-click share:
      // - On mobile: uses native share sheet (Facebook/IG/Discord/Reddit/等，如果已安裝 app)
      // - On desktop: falls back to auto-download + copy caption (平台限制無法自動發文上傳圖片)
      const oneClickShare = async ()=>{
        try{ await copyCaption(); }catch(_){}
        try{ await systemShare(); }catch(_){}
        // We can't reliably verify posting success across platforms, so reward is granted per-shareId with daily cap.
        await claimReward();
      };

      // Hide advanced buttons (keep DOM ids for backward compatibility)
      if(shareDownload) shareDownload.style.display = "none";
      if(shareCopy) shareCopy.style.display = "none";
      if(shareReddit) shareReddit.style.display = "none";
      if(shareClaim) shareClaim.style.display = "none";

      if(shareShare) shareShare.onclick = oneClickShare;



      // Close behavior
      const close = () => {
        hideCinematic();
        try{ hideOverlay(); }catch(_){}
      };
      cineOk.onclick = close;
      const bg = cinematic.querySelector(".cine-bg");
      if(bg) bg.onclick = close;

      // suspense & FX
      await sleep(180);
      cinematic.classList.remove("black");
      sfxByRarity(r);

      if(r >= 4){
        await sleep(140);
        cinematic.classList.add("shake");
        cinematic.classList.add("flash");
      }else if(r === 3){
        await sleep(120);
        cinematic.classList.add("flash");
      }else{
        await sleep(90);
        cinematic.classList.add("flash");
      }

      await sleep(520);
      if(r >= 4) cinematic.classList.add("float");

      // stay on screen until user confirms
    }

    function hideCinematic(){
      const cinematic = document.getElementById("cinematic");
      if(!cinematic) return;
      cinematic.className = "cinematic";
      cinematic.setAttribute("aria-hidden","true");
      const cineImg = document.getElementById("cineImg");
      if(cineImg) cineImg.removeAttribute("src");
      const cineTenGrid = document.getElementById("cineTenGrid");
      if(cineTenGrid) cineTenGrid.innerHTML = "";
      const cineTen = document.getElementById("cineTen");
      if(cineTen) cineTen.classList.remove("show");
      // restore underlying confirm for non-cinematic paths
      if(typeof confirmBtn !== "undefined" && confirmBtn){
        confirmBtn.style.opacity = "1";
        confirmBtn.style.pointerEvents = "auto";
      }
    }



    function pickUniqueIndices(n, k){
      const out = [];
      const used = new Set();
      while(out.length < k && used.size < n){
        const x = Math.floor(Math.random()*n);
        if(used.has(x)) continue;
        used.add(x);
        out.push(x);
      }
      // fallback deterministic fill
      for(let i=0; out.length<k && i<n; i++){
        if(!used.has(i)){ used.add(i); out.push(i); }
      }
      return out;
    }

    
    const GRID_ROWS = 3;
    const GRID_COLS = 10;
    const GRID_COUNT = GRID_ROWS * GRID_COLS; // 30

function renderGridDecoys(list){
      grid32El.innerHTML = "";
      const frag = document.createDocumentFragment();
      for(let i=0;i<GRID_COUNT;i++){
        const a = list[i] || {id:"unknown", rarity:1, thumb:"/assets/placeholder.png"};
        const cell = document.createElement("div");
        cell.className = "cell";
        const wrap = document.createElement("div");
        wrap.className = "thumbWrap";
        const img = document.createElement("img");
        img.loading = "eager";
        img.decoding = "async";
        img.src = assetThumb(a);
        const lab = document.createElement("div");
        lab.className = "label";
        lab.textContent = assetLabel(a);
        wrap.appendChild(img);
        cell.appendChild(wrap);
        cell.appendChild(lab);
        frag.appendChild(cell);
      }
      grid32El.appendChild(frag);
      // clear states
      grid32El.querySelectorAll(".cell").forEach(c=>c.classList.remove("win","win2","red","dim"));
    }

    function getGridCellRects(){
      const cells = Array.from(grid32El.querySelectorAll(".cell"));
      // reset winner visuals
      cells.forEach(c=>c.classList.remove("win","win2","red"));
      const stageRect = framesLayer.getBoundingClientRect();
      return cells.map(c=>{
        // 框只對齊到圖片區域，不包含文字 label
        const target = c.querySelector(".thumbWrap") || c;
        const r = target.getBoundingClientRect();
        return {
          left: r.left - stageRect.left,
          top: r.top - stageRect.top,
          width: r.width,
          height: r.height
        };
      });
    }
    function placeFrame(frame, rect){
      frame.style.left = rect.left + "px";
      frame.style.top = rect.top + "px";
      frame.style.width = rect.width + "px";
      frame.style.height = rect.height + "px";
    }

    
    async function animateJumpGridToSlots(winnerSlots, winners, isTen){
      let rects = getGridCellRects();

      framesLayer.innerHTML = "";
      hideCinematic();

      const cells = Array.from(grid32El.querySelectorAll(".cell"));
      // start: all dark
      cells.forEach(c=>c.classList.remove("win","win2","red","focus"));
      cells.forEach(c=>c.classList.add("dim"));

      const finalSlotsAll = Array.isArray(winnerSlots) ? winnerSlots.slice() : [];
      const framesCount = isTen ? 10 : 1;
      const finalSlots = finalSlotsAll.slice(0, framesCount);
      while(finalSlots.length < framesCount) finalSlots.push(0);

      // one visible frame for ten-pull (clearer), single frame for single-pull
      const frame = document.createElement("div");
      frame.className = "jump-frame gold";
      framesLayer.appendChild(frame);

      // start position
      let slotNow = pickUniqueIndices(GRID_COUNT, 1)[0] || 0;
      placeFrame(frame, rects[slotNow]);
      frame.classList.remove("jump");
      void frame.offsetWidth;
      frame.classList.add("jump");

      // helper: run a mini spin then land on target slot
      async function spinAndLand(targetSlot, idx, total){
        // spin
        const steps = isTen ? 18 : 30;
        let interval = 34;
        for(let s=0;s<steps;s++){
          await sleep(interval);
          rects = getGridCellRects();
          slotNow = pickUniqueIndices(GRID_COUNT, 1)[0] || slotNow;
          placeFrame(frame, rects[slotNow]);
          frame.classList.remove("jump");
          void frame.offsetWidth;
          frame.classList.add("jump");
          if(s > steps*0.55) interval = Math.min(190, Math.round(interval*1.10 + 3));
        }

        // land
        await sleep(90);
        rects = getGridCellRects();
        slotNow = targetSlot;
        placeFrame(frame, rects[slotNow]);
        frame.classList.remove("jump");
        void frame.offsetWidth;
        frame.classList.add("jump");

        // frame style: last one red
        if(isTen && idx === total - 1){
          frame.classList.remove("gold");
          frame.classList.add("red");
        }else{
          frame.classList.remove("red");
          frame.classList.add("gold");
        }

        const cell = cells[slotNow];
        if(cell){
          cell.classList.remove("dim");
          cell.classList.add("win","focus");
          if(isTen && idx === total - 1) cell.classList.add("red");
          setTimeout(()=>cell.classList.add("win2"), 30);
          setTimeout(()=>cell.classList.remove("focus"), 280);
        }

        const w = Array.isArray(winners) ? winners[idx] : null;
        const rr = Math.max(1, Math.min(5, Number(w?.rarity || 1)));

        // apply rarity class to landed cell for stronger visual difference
        if(cell){
          ["r1","r2","r3","r4","r5"].forEach(x=>cell.classList.remove(x));
          cell.classList.add(`r${rr}`);
        }

        sfxByRarity(rr);
        packHitFx(rr);

        await sleep(isTen ? 260 : 0);
      }

      if(isTen){
        // stop one by one, each stop lights up that card
        for(let i=0;i<framesCount;i++){
          await spinAndLand(finalSlots[i], i, framesCount);
        }
      }else{
        // single pull: one landing
        await spinAndLand(finalSlots[0], 0, 1);
      }

      // keep non-winners dark, winners already lit
      const winSet = new Set(finalSlots);
      cells.forEach((c, idx)=>{
        if(winSet.has(idx)) c.classList.remove("dim");
        else c.classList.add("dim");
      });

      // keep frame on last landed card
      frame.classList.remove("fade");
    }

    async function buildGridWithPulled(pulled, opts={}){
      const assets = await ensureAssetsLoaded();
      const wantType = opts && opts.type ? normalizeType(opts.type) : null;

      // Decoy pool (never grants items): use /api/assets list filtered by type if requested
      let pool = Array.isArray(assets) ? assets.slice() : [];
      if(wantType){
        pool = pool.filter(a => normalizeType(a && a.type) === wantType);
      }

      // Winners: what the backend actually granted (1 or 10)
      const winners = Array.isArray(pulled) ? pulled.slice() : [];
      const winnersCount = (Number(opts.count||1) === 10) ? 10 : 1;

      // Normalize winners length
      const finalWinners = winners.slice(0, winnersCount);
      while(finalWinners.length < winnersCount && winners[finalWinners.length]) finalWinners.push(winners[finalWinners.length]);

      // Build 20/29 decoys
      const decoyCount = GRID_COUNT - winnersCount;
      const decoys = [];
      if(pool.length > 0){
        for(let i=0;i<decoyCount;i++){
          decoys.push(pool[Math.floor(Math.random()*pool.length)]);
        }
      }else{
        for(let i=0;i<decoyCount;i++) decoys.push({id:"unknown", rarity:1, thumb:"/assets/placeholder.png"});
      }

      // Place winners into random slots within the 30-grid
      const winnerSlots = pickUniqueIndices(GRID_COUNT, winnersCount);
      const grid = new Array(GRID_COUNT).fill(null);

      // fill winners
      for(let i=0;i<winnersCount;i++){
        grid[winnerSlots[i]] = finalWinners[i] || {id:"unknown", rarity:1, thumb:"/assets/placeholder.png"};
      }
      // fill remaining with decoys
      let di=0;
      for(let i=0;i<GRID_COUNT;i++){
        if(grid[i]) continue;
        grid[i] = decoys[di++] || {id:"unknown", rarity:1, thumb:"/assets/placeholder.png"};
      }

      // Preload thumbs before showing new 30 cards so previous pack never flashes
      try{
        const urls = grid.map(a=>assetThumb(a));
        await preloadImages(urls, 8000);
      }catch(_){}

      renderGridDecoys(grid);
      hideLoad();

      // Clear any dim/frames state before animation
      const cells = Array.from(grid32El.querySelectorAll(".cell"));
      cells.forEach(c=>c.classList.remove("win","win2","red","dim"));

      // let browser paint
      overlay.offsetHeight;
      await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));

      return { winnerSlots, winners: finalWinners };
    }

    async function prepareGridStage(opts={}){
      // Backward-compatible wrapper (not used by the new flow)
      const data = await onlineGacha(opts);
      return buildGridWithPulled(data.pulled, opts);
    }

    async function startGacha(opts={}){
      if(animating) return;
      animating = true;

      try{
        if(actionBar){ actionBar.classList.add("mode-loading"); actionBar.classList.remove("mode-done"); }
        confirmBtn.style.opacity = "0";
        confirmBtn.style.pointerEvents = "none";
        showOverlay();
        // Cover previous 30 cards until the new 30 cards are fully loaded
        showLoad("載入中");

        // 1) Get the real awarded cards first (backend decides)
        if(rollingText) rollingText.style.display = "";
        if(rollSub) rollSub.style.display = "none";
        if(rollSub) rollSub.textContent = "";
        
        const data = await onlineGacha(opts);
        const pulled = data && Array.isArray(data.pulled) ? data.pulled : [];
        if(!pulled || pulled.length === 0) throw new Error("empty");
        try{ updatePityUI(data); }catch(_){ }

        // 2) Build the 30-card grid BEFORE animation:
        //    30 cards include the 1/10 real rewards, plus decoys (from /api/assets) for visuals only
        // still showing rollingText below cards while preparing

        const isTen = Number(opts.count||1) === 10;
        const pack = await buildGridWithPulled(pulled, opts);

        // 3) Run animation but DO NOT change grid content; only land frames onto the pre-decided winners
        if(rollingText) rollingText.style.display = "";
        if(rollSub) rollSub.style.display = "none";
        if(rollSub) rollSub.textContent = "";
        
        await animateJumpGridToSlots(pack.winnerSlots, pack.winners, isTen);

        // V2: cinematic reveal (single = big card, ten = 10 thumbnails)
        try{
          const winners = Array.isArray(pack.winners) ? pack.winners : [];
          await playCinematicForPack(winners, isTen);
        }catch(_){ /* ignore cinematic errors */ }

        if(rollingText) rollingText.style.display = "none";
        if(rollSub){ rollSub.style.display = ""; rollSub.textContent = isTen ? "" : ""; }
        if(actionBar){ actionBar.classList.add("mode-done"); actionBar.classList.remove("mode-loading"); }
        confirmBtn.style.opacity = "1";
        confirmBtn.style.pointerEvents = "auto";
        animating = false;
      }catch(e){
        console.error(e);
        hideLoad();
        if(rollingText) rollingText.style.display = "none";
        if(rollSub){ rollSub.style.display = ""; rollSub.textContent = "抽卡失敗"; }
        toast("抽卡失敗");
        if(actionBar){ actionBar.classList.add("mode-done"); actionBar.classList.remove("mode-loading"); }
        confirmBtn.style.opacity = "1";
        confirmBtn.style.pointerEvents = "auto";
        animating = false;
      }
    }
    loadFeaturedVideo();
    loadPityStatus();

    btnNormal1.addEventListener("click", () => startGacha({ count: 1, premium: false }));
    btnNormal10.addEventListener("click", () => startGacha({ count: 10, premium: false }));
    btnPremium1.addEventListener("click", () => startGacha({ count: 1, premium: true }));
    btnPremium10.addEventListener("click", () => startGacha({ count: 10, premium: true }));

    // 右側 5 個分類區塊 (普通抽卡 但強制 type)
    btnHead1.addEventListener("click", () => startGacha({ count: 1, premium: false, type: "head" }));
    btnHead10.addEventListener("click", () => startGacha({ count: 10, premium: false, type: "head" }));

    btnBody1.addEventListener("click", () => startGacha({ count: 1, premium: false, type: "body" }));
    btnBody10.addEventListener("click", () => startGacha({ count: 10, premium: false, type: "body" }));

    btnBg1.addEventListener("click", () => startGacha({ count: 1, premium: false, type: "background" }));
    btnBg10.addEventListener("click", () => startGacha({ count: 10, premium: false, type: "background" }));

    btnAddon11.addEventListener("click", () => startGacha({ count: 1, premium: false, type: "addon1" }));
    btnAddon110.addEventListener("click", () => startGacha({ count: 10, premium: false, type: "addon1" }));

    btnAddon21.addEventListener("click", () => startGacha({ count: 1, premium: false, type: "addon2" }));
    btnAddon210.addEventListener("click", () => startGacha({ count: 10, premium: false, type: "addon2" }));
  </script>

  <!-- V2 cinematic rarity reveal (fixed layer, never blocks clicks) -->
  <div class="cinematic" id="cinematic" aria-hidden="true">
    <div class="cine-bg"></div>
    <div class="cine-black"></div>
    <div class="cine-flash"></div>
    <div class="cine-shake"></div>
    <div class="cine-glow"></div>
    <div class="cine-core" role="dialog" aria-modal="true">
      <div class="cine-rarity" id="cineRarity">UR</div>
      <div class="cine-sub" id="cineSub">恭喜獲得</div>

      <div class="cine-card"><img id="cineImg" alt="reward" /></div>

      <div class="cine-ten" id="cineTen">
        <div class="cine-ten-title" id="cineTenTitle">10連抽結果</div>
        <div class="cine-ten-subtitle"></div>
        <div class="cine-ten-g" id="cineTenGuarantee"></div>
        <div class="cine-ten-subtitle"></div>
        <div class="cine-ten-grid" id="cineTenGrid"></div>
      </div>

      <button class="cine-ok" id="cineOk" type="button">確認</button>

      <div class="sharePanel" id="sharePanel" style="display:none;">
        <div class="shareTitle">分享抽卡結果</div>
        <div class="shareBody">
          <img id="sharePreview" alt="share preview" />
          <div class="shareBtns">
            <button class="shareBtn" id="shareDownload" type="button">下載圖片</button>
            <button class="shareBtn" id="shareCopy" type="button">複製文案</button>
            <button class="shareBtn" id="shareShare" type="button">一鍵分享</button>
            <button class="shareBtn" id="shareReddit" type="button">Reddit</button>
            <button class="shareBtn shareClaim" id="shareClaim" type="button">領取獎勵</button>
          </div>
        </div>
        <div class="shareHint" id="shareHint">抽到 SSR 或 UR 才會出現分享圖，分享到 Discord Reddit 朋友圈後再點領取獎勵，每天最多 5 次</div>
      </div>

      <div class="cine-cta" id="cineCta">點擊確認繼續</div>
    </div>
  </div>

  <canvas id="shareCanvas" width="1080" height="1080" style="display:none;"></canvas>

</body>
</html>
